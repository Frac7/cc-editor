/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./js/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./js/components/graphics.js":
/*!***********************************!*\
  !*** ./js/components/graphics.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utilities_graphics_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities/graphics/map */ \"./js/utilities/graphics/map.js\");\n/* harmony import */ var _utilities_dictionary_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utilities/dictionary/map */ \"./js/utilities/dictionary/map.js\");\n\n\n\n/**\n * Graphics widget.\n * @extends HTMLElement\n */\nclass Graphics extends HTMLElement {\n  constructor() {\n    super();\n  }\n\n  connectedCallback () {\n    this.validator();\n  }\n\n  static get observedAttributes() {\n    return [ 'expanded', 'color', 'background', 'size', 'border', 'font', 'shadow' ];\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    this.validator();\n  }\n\n  /**\n   * Get expanded flag.\n   * @return {boolean} Expanded flag\n   */\n  get expanded () {\n    return this.hasAttribute('expanded');\n  }\n  /**\n   * Set expanded flag.\n   * @param {boolean} expanded Expanded flag\n   */\n  set expanded (expanded) {\n    this.setAttribute('expanded', expanded);\n  }\n\n  /**\n   * Get text color.\n   * @return {string} Text color\n   */\n  get color () {\n    return this.getAttribute('color');\n  }\n  /**\n   * Set text color.\n   * @param {string} color Text color\n   */\n  set color (color) {\n    this.setAttribute('color', color);\n  }\n\n  /**\n   * Get background color.\n   * @return {string} Background color\n   */\n  get background () {\n    return this.getAttribute('background');\n  }\n  /**\n   * Set background color.\n   * @param {string} background Background color\n   */\n  set background (background) {\n    this.setAttribute('background', background);\n  }\n\n  /**\n   * Get element size.\n   * @return {string} Element size\n   */\n  get size () {\n    return this.getAttribute('size');\n  }\n  /**\n   * Set element size.\n   * @param {string} size Element size\n   */\n  set size (size) {\n    this.setAttribute('size', size);\n  }\n\n  /**\n   * Get element border.\n   * @return {string} Element border\n   */\n  get border () {\n    return this.getAttribute('border');\n  }\n  /**\n   * Set element border.\n   * @param {string} border Element border\n   */\n  set border (border) {\n    this.setAttribute('border', border);\n  }\n\n  /**\n   * Get element font.\n   * @return {string} Element font\n   */\n  get font () {\n    return this.getAttribute('font');\n  }\n  /**\n   * Set element font.\n   * @param {string} font Element font\n   */\n  set font (font) {\n    this.setAttribute('font', font);\n  }\n\n  /**\n   * Get element shadow.\n   * @return {string} Element shadow\n   */\n  get shadow () {\n    return this.getAttribute('shadow');\n  }\n  /**\n   * Set element shadow.\n   * @param {string} shadow Element shadow\n   */\n  set shadow (shadow) {\n    this.setAttribute('shadow', shadow);\n  }\n\n  /**\n   * Get semantics target.\n   * @return {string} Element shadow\n   */\n  get target () {\n    return this.getAttribute('target');\n  }\n  /**\n   * Set semantics target.\n   * @param {string} target Semantics target\n   */\n  set target (target) {\n    this.setAttribute('target', target);\n  }\n\n  /**\n   * Graphics attributes validator.\n   * @method\n   * @memberof Graphics\n   */\n  validator () {\n    const hasValidSize = this.size ? this.size === _utilities_graphics_map__WEBPACK_IMPORTED_MODULE_0__[\"SMALL\"] || this.size === _utilities_graphics_map__WEBPACK_IMPORTED_MODULE_0__[\"LARGE\"] || this.size === _utilities_graphics_map__WEBPACK_IMPORTED_MODULE_0__[\"MEDIUM\"] : true;\n    const hasValidTarget = this.target ? _utilities_dictionary_map__WEBPACK_IMPORTED_MODULE_1__[\"semantics\"].includes(this.target) : true;\n    const isValidComponent = hasValidSize && hasValidTarget;\n\n    if (isValidComponent) {\n      return true;\n    }\n\n    throw new Error('Invalid graphic attributes.');\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Graphics);\n\n\n//# sourceURL=webpack:///./js/components/graphics.js?");

/***/ }),

/***/ "./js/components/index.js":
/*!********************************!*\
  !*** ./js/components/index.js ***!
  \********************************/
/*! exports provided: Widget, Semantics, Graphics, Vocal */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _widget__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./widget */ \"./js/components/widget.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Widget\", function() { return _widget__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; });\n\n/* harmony import */ var _semantics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./semantics */ \"./js/components/semantics.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Semantics\", function() { return _semantics__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; });\n\n/* harmony import */ var _graphics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./graphics */ \"./js/components/graphics.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Graphics\", function() { return _graphics__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; });\n\n/* harmony import */ var _vocal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vocal */ \"./js/components/vocal.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Vocal\", function() { return _vocal__WEBPACK_IMPORTED_MODULE_3__[\"default\"]; });\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack:///./js/components/index.js?");

/***/ }),

/***/ "./js/components/semantics.js":
/*!************************************!*\
  !*** ./js/components/semantics.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utilities_dictionary_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities/dictionary/map */ \"./js/utilities/dictionary/map.js\");\n\n\n/**\n * Semantics widget.\n * @extends HTMLElement\n */\nclass Semantics extends HTMLElement {\n  constructor() {\n    super();\n  }\n\n  connectedCallback() {\n    this.validator();\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    this.validator();\n  }\n\n  /**\n   * Get semantics type.\n   * @return {string} Semantics type\n   */\n  get semantics () {\n    return this.getAttribute('semantics');\n  }\n  /**\n   * Set semantics type.\n   * @param {string} semantics Semantics type\n   */\n  set semantics (semantics) {\n    this.setAttribute('semantics', semantics);\n  }\n  \n  /**\n   * Get single choice/data acquisition type.\n   * @return {string} Type\n   */\n  get type () {\n    return this.getAttribute('type');\n  }\n  /**\n   * Set single choice/data acquisition type.\n   * @param {string} type Type\n   */\n  set type (type) {\n    this.setAttribute('type', type);\n  }\n  \n  /**\n   * Get multiple flag for selection choice.\n   * @return {boolean} Multiple flag\n   */\n  get multiple () {\n    return this.hasAttribute('multiple');\n  }\n  /**\n   * Set multiple flag for selection choice.\n   * @param {boolean} multiple Multiple flag\n   */\n  set multiple (multiple) {\n    this.setAttribute('multiple', multiple);\n  }\n\n  /**\n   * Get link for navigating.\n   * @return {string} Link\n   */\n  get to () {\n    return this.getAttribute('to');\n  }\n  /**\n   * Set link for navigating.\n   * @param {string} to Link\n   */\n  set to (to) {\n    this.setAttribute('to', to);\n  }\n\n  /**\n   * Get label text.\n   * @return {string} Label text\n   */\n  get text () {\n    return this.getAttribute('text');\n  }\n  /**\n   * Set label text.\n   * @param {string} text Label text\n   */\n  set text (text) {\n    this.setAttribute('text', text);\n  }\n\n  /**\n   * Get element reference.\n   * @return {string} Element reference\n   */\n  get element () {\n    return this.getAttribute('element');\n  }\n  /**\n   * Set element reference.\n   * @param {string} element Element reference\n   */\n  set element (element) {\n    this.setAttribute('element', element);\n  }\n\n  /**\n   * Get element value.\n   * @return {string} Element value\n   */\n  get value () {\n    return this.getAttribute('value');\n  }\n  /**\n   * Set element value.\n   * @param {string} value Element reference\n   */\n  set value (value) {\n    this.setAttribute('value', value);\n  }\n\n  /**\n * Semantics attributes validator.\n * @method\n * @memberof Semantics\n */\n  validator() {\n    const semanticsAttrError = (attrs) => `This type of semantics can only have: ${attrs} attribute(s).`;\n\n    const isValidSemantics = _utilities_dictionary_map__WEBPACK_IMPORTED_MODULE_0__[\"semantics\"].includes(this.semantics);\n    if (!isValidSemantics) {\n      throw new Error('Incorrect \"semantics\" attribute.');\n    }\n\n    const hasTypeAttr = this.type && !this.to && !this.text && !this.multiple; //could have element and must have semantics\n\n    const isSingleChoice = _utilities_dictionary_map__WEBPACK_IMPORTED_MODULE_0__[\"singleChoiceTypes\"].includes(this.type) && this.semantics === _utilities_dictionary_map__WEBPACK_IMPORTED_MODULE_0__[\"SINGLE_CHOICE\"]; //button types\n    const isDataAcquisition = _utilities_dictionary_map__WEBPACK_IMPORTED_MODULE_0__[\"dataAcquisitionTypes\"].includes(this.type) && this.semantics && _utilities_dictionary_map__WEBPACK_IMPORTED_MODULE_0__[\"DATA_ACQUISITION\"]; //input types\n\n    if (hasTypeAttr && (isSingleChoice || isDataAcquisition)) {\n      return true;\n    } else if (this.type && !hasTypeAttr) {\n      throw new Error(semanticsAttrError('\"type\", \"semantics\", \"element\", \"value\"'));\n    } else if (hasTypeAttr && (!isSingleChoice && !isDataAcquisition)) {\n      throw new Error('Incorrect \"type\" attribute.');\n    }\n\n    const isSelectionChoice = this.element && !this.type && !this.to && !this.text; //all the selection choice types must have element (for label and option) and could have value\n    if (isSelectionChoice && this.semantics === _utilities_dictionary_map__WEBPACK_IMPORTED_MODULE_0__[\"SELECTION_CHOICE\"]) {\n      return true;\n    } else if (this.semantics === _utilities_dictionary_map__WEBPACK_IMPORTED_MODULE_0__[\"SELECTION_CHOICE\"]) {\n      throw new Error(semanticsAttrError('\"multiple\", \"semantics\", \"element\"'));\n    }\n\n    const isNavigation = this.to && !this.type && !this.value && !this.text && !this.multiple; //could have element and must have semantics\n    if (isNavigation && this.semantics === _utilities_dictionary_map__WEBPACK_IMPORTED_MODULE_0__[\"NAVIGATION\"]) {\n      return true;\n    } else if (this.to) {\n      throw new Error(semanticsAttrError('\"to\", \"semantics\", \"element\"'));\n    }\n\n    const labelOrOption = !this.type && !this.to && !this.multiple && \n      ((this.text && !this.value && this.semantics === _utilities_dictionary_map__WEBPACK_IMPORTED_MODULE_0__[\"LABEL\"]) || (this.value && !this.text && this.element && this.semantics === _utilities_dictionary_map__WEBPACK_IMPORTED_MODULE_0__[\"OPTION\"])); //label could not have element attr \n    if (labelOrOption) {\n      return true;\n    } else if (this.element || labelOrOption) {\n      throw new Error(semanticsAttrError('\"element\", \"text\"/\"value\", \"semantics\"'));\n    }\n\n    throw new Error('Invalid semantic attributes.');\n  }\n\n  static get observedAttributes() {\n    return [ \n      'semantics', \n      'type', \n      'multiple',\n      'text',\n      'to',\n      'element',\n      'value'\n    ];\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Semantics);\n\n\n//# sourceURL=webpack:///./js/components/semantics.js?");

/***/ }),

/***/ "./js/components/vocal.js":
/*!********************************!*\
  !*** ./js/components/vocal.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utilities_vocal_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities/vocal/map */ \"./js/utilities/vocal/map.js\");\n\n\n/**\n * Vocal widget.\n */\nclass Vocal extends HTMLElement {\n  constructor() {\n    super();\n  }\n\n  connectedCallback () {\n    this.validator();\n  }\n\n  static get observedAttributes() {\n    return [ 'event', 'keyword' ];\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    this.validator();\n  }\n\n  /**\n   * Get the event to trigger.\n   * @returns {string} Event\n   */\n  get event () {\n    return this.getAttribute('event');\n  }\n  /**\n   * Set the event to trigger.\n   * @param {string} event Event\n   */\n  set event (event) {\n    this.setAttribute('event', event);\n  }\n\n  /**\n   * Get the keyowrd for triggering the event.\n   * @returns {string} Keyword\n   */\n  get keyword () {\n    return this.getAttribute('keyword');\n  }\n  /**\n   * Set the keyowrd for triggering the event.\n   * @param {string} keyword Keyword\n   */\n  set keyword (keyword) {\n    this.setAttribute('keyword', keyword);\n  }\n\n  /**\n   * Vocal attributes validator.\n   * @method\n   * @memberof Vocal\n   */\n  validator () {\n    const isValidEvent = _utilities_vocal_map__WEBPACK_IMPORTED_MODULE_0__[\"events\"].includes(this.event);\n    if (isValidEvent && typeof this.keyword === 'string') {\n        return true;\n    }\n\n    throw new Error('Invalid \"event\" and \"keyword\" attributes.');\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Vocal);\n\n//# sourceURL=webpack:///./js/components/vocal.js?");

/***/ }),

/***/ "./js/components/widget.js":
/*!*********************************!*\
  !*** ./js/components/widget.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utilities_dictionary_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities/dictionary/map */ \"./js/utilities/dictionary/map.js\");\n/* harmony import */ var _utilities_graphics_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utilities/graphics/map */ \"./js/utilities/graphics/map.js\");\n/* harmony import */ var _utilities_dictionary__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utilities/dictionary */ \"./js/utilities/dictionary/index.js\");\n/* harmony import */ var _utilities_graphics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utilities/graphics */ \"./js/utilities/graphics/index.js\");\n/* harmony import */ var _utilities_vocal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utilities/vocal */ \"./js/utilities/vocal/index.js\");\n\n\n\n\n\n\n\n/**\n * Parent widget.\n * @extends HTMLElement\n */\nclass Widget extends HTMLElement {\n  constructor() {\n    super();\n  }\n\n  connectedCallback() {\n    this.validator();\n    this.createWidget();\n\n    [ ...this.children ].forEach((child) => {\n      const observer = new MutationObserver((mutations) => {\n        this.shadowRoot.innerHTML = '';\n        this.validator();\n        this.createWidget();\n      });\n      observer.observe(child, { \n        attributes: true\n      });\n    })\n  }\n\n  /**\n   * Creates widget based on children components\n   */\n  createWidget () {\n    const shadow = this.shadowRoot || this.parentElement.shadowRoot || this.attachShadow({ 'mode': 'open' });\n\n    const children = [...this.children];\n\n    const components = {\n      [_utilities_dictionary_map__WEBPACK_IMPORTED_MODULE_0__[\"SEMANTICS\"]]: [],\n      [_utilities_dictionary_map__WEBPACK_IMPORTED_MODULE_0__[\"GRAPHICS\"]]: [],\n      [_utilities_dictionary_map__WEBPACK_IMPORTED_MODULE_0__[\"VOCAL\"]]: []\n    };\n\n    //First collect component name and attributes from each child\n    children.forEach((child) => {\n      const tagName = child.tagName.toLowerCase();\n      if (tagName !== _utilities_dictionary_map__WEBPACK_IMPORTED_MODULE_0__[\"CONTAINER\"]) {\n        //These are all the possibile attributes\n\n        //semantics\n        const semantics = child.getAttribute('semantics');\n        const type = child.getAttribute('type');\n        const multiple = child.hasAttribute('multiple');\n        const to = child.getAttribute('to');\n        const value = child.getAttribute('value');\n        const text = child.getAttribute('text');\n        const element = child.getAttribute('element');\n\n        //graphics\n        const expanded = child.hasAttribute('expanded');\n        const color = child.getAttribute('color');\n        const background = child.getAttribute('background');\n        const size = child.getAttribute('size');\n        const border = child.getAttribute('border');\n        const font = child.getAttribute('font');\n        const shadow = child.getAttribute('shadow');\n        const target = child.getAttribute('target');\n\n        //vocal\n        const event = child.getAttribute('event');\n        const keyword = child.getAttribute('keyword');\n\n        //DOM default flags (validated by default from the DOM)\n        const disabled = child.hasAttribute('disabled');\n        const checked = child.hasAttribute('checked');\n        const required = child.hasAttribute('required');\n        const readonly = child.hasAttribute('readonly');\n        const selected = child.hasAttribute('selected');\n\n        components[tagName].push(Object.assign({}, \n          semantics && { semantics },\n          type && { type },\n          multiple && { multiple },\n          to && { to },\n          value && { value },\n          text && { text },\n          element && { element },\n          expanded && { expanded },\n          target && { target },\n          event && { event },\n          keyword && { keyword },\n          disabled && { disabled },\n          checked && { checked },\n          required && { required },\n          readonly && { readonly },\n          selected && { selected },\n          {\n            style: Object.assign({}, \n              color && { color },\n              background && { background },\n              size && { size },\n              border && { border },\n              font && { font },\n              shadow && { shadow }\n            )\n          })\n        );\n      }\n    });\n    \n    //Then create prototypes combining children and using dictionary\n    const widget = components[_utilities_dictionary_map__WEBPACK_IMPORTED_MODULE_0__[\"SEMANTICS\"]].reduce((accumulator, { semantics, ...attrs }) => ({ //reducer\n      semantics: [ ...accumulator.semantics, ...[ semantics ]], \n      attrs: { ...accumulator.attrs, ...attrs }\n    }), { //accumulator\n        semantics: [],\n        attrs: {}\n      }\n    );\n\n    if (widget.semantics.length > 1) {\n      if (widget.semantics.includes(_utilities_dictionary_map__WEBPACK_IMPORTED_MODULE_0__[\"LABEL\"]) && \n        (widget.semantics.includes(_utilities_dictionary_map__WEBPACK_IMPORTED_MODULE_0__[\"OPTION\"]) || widget.semantics.includes(_utilities_dictionary_map__WEBPACK_IMPORTED_MODULE_0__[\"SINGLE_CHOICE\"]) || widget.semantics.includes(_utilities_dictionary_map__WEBPACK_IMPORTED_MODULE_0__[\"NAVIGATION\"]))) {\n        //Label is inner text\n        widget.semantics = [widget.semantics[widget.semantics.length - widget.semantics.indexOf(_utilities_dictionary_map__WEBPACK_IMPORTED_MODULE_0__[\"LABEL\"]) - 1]];\n      }\n    }\n\n    //This step adds graphics (both style (and eventually target) attributes and expanded attribute, used for dictionary)\n    const graphics = components[_utilities_dictionary_map__WEBPACK_IMPORTED_MODULE_0__[\"GRAPHICS\"]].reduce((accumulator, { target, ...attrs }) => ({\n      ...accumulator,\n      ...attrs,\n      style: { \n        ...accumulator.style, \n        ...Object.assign({}, !target && { '*': { ...accumulator.style['*'], ...attrs.style }}), //without target\n        ...Object.assign({}, target && { [target]: { ...accumulator.style[target], ...attrs.style } }) //with target\n      } //add nested style attrs\n    }), {\n        style: {\n          '*': {} //default selector for all elements\n        }\n    });\n\n    widget.attrs = {\n      ...widget.attrs,\n      ...graphics\n    };\n\n    //Create the widget starting from each semantics\n    widget.semantics.forEach((semantics) => {\n      const prototype = Object(_utilities_dictionary__WEBPACK_IMPORTED_MODULE_2__[\"default\"])((semantics), widget.attrs);\n\n      const { tag, ...attributes } = prototype;\n      const element = document.createElement(tag);\n  \n      Object.keys(attributes).forEach((key) => {\n        element[key] = attributes[key];\n      });\n      \n      //Apply style\n      if (Object.keys(widget.attrs.style).length > 0) {\n        const target = widget.attrs.style[semantics] ? semantics : '*';\n        const cssSelector = widget.attrs.style[semantics] ? tag : '*';\n\n        const styleKeys = Object.keys(widget.attrs.style[target]);\n\n        if (styleKeys.length > 0) {\n          const style = shadow.querySelector('style') || document.createElement('style');\n          style.type = 'text/css';\n\n          const styleTextNode = `\\n${cssSelector} {${styleKeys.reduce((accumulator, key) => \n            `${accumulator}\\n\\t${Object(_utilities_graphics__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(key, widget.attrs.style[target][key], tag)};`, '')}\n}\\n`;\n\n          !style.innerText.includes(styleTextNode) && style.appendChild(document.createTextNode(styleTextNode)); //workaround\n          \n          //Another step to add visual feedback, hidden by customization (:hover, [disabled])\n          if ((styleKeys.includes(_utilities_graphics_map__WEBPACK_IMPORTED_MODULE_1__[\"BACKGROUND\"]) || styleKeys.includes(_utilities_graphics_map__WEBPACK_IMPORTED_MODULE_1__[\"BORDER\"])) && (tag === 'button' || tag === 'select')) {\n            style.appendChild(document.createTextNode(\n              `${tag}:hover:not([disabled]) {\\n\\tcursor: pointer;\n}\\n${tag}[disabled] {\\n\\tbox-shadow: none;\\n\\tborder: none;\\n\\tbackground: gainsboro;\\n\\tcolor: gray;\\n\\t\n}`\n            ));\n          }\n\n          shadow.appendChild(style);\n        }\n      }\n  \n      //Finally bind events and keywords based on vocal components\n      if (semantics !== _utilities_dictionary_map__WEBPACK_IMPORTED_MODULE_0__[\"LABEL\"] && semantics !== _utilities_dictionary_map__WEBPACK_IMPORTED_MODULE_0__[\"OPTION\"]) {\n        components[_utilities_dictionary_map__WEBPACK_IMPORTED_MODULE_0__[\"VOCAL\"]].forEach(({ event, keyword }) => {\n          Object(_utilities_vocal__WEBPACK_IMPORTED_MODULE_4__[\"addKeyword\"])(event, keyword, widget.attrs.element, semantics, element);\n    \n          //TODO: this line is only for debug purpose, remove this\n          element.addEventListener(event, (e) => console.log(e));\n        });\n      }\n  \n      semantics === _utilities_dictionary_map__WEBPACK_IMPORTED_MODULE_0__[\"OPTION\"] ? shadow.querySelector(`#${widget.attrs.element}`).appendChild(element) : shadow.appendChild(element);\n    });\n  }\n\n  /**\n   * Parent widget children validator.\n   * @method\n   * @memberof Widget\n   */\n  validator () {\n    const children = [...this.children];\n\n    const semantics = children\n    .filter((item) => item.tagName.toLowerCase() === _utilities_dictionary_map__WEBPACK_IMPORTED_MODULE_0__[\"SEMANTICS\"]);\n    const semanticsAttrs = semantics.map((item) => item.getAttributeNames()).flat();\n    const semanticTargets = semantics.reduce((accumulator, item) => [ ...accumulator, item.getAttribute('semantics')], []);\n\n    const differentSemantics = semanticTargets.length === new Set(semanticTargets).size;\n\n    //Validate combination of semantics\n    if (!differentSemantics || (semanticTargets.length > 1 && !semanticTargets.includes(_utilities_dictionary_map__WEBPACK_IMPORTED_MODULE_0__[\"LABEL\"])) || semanticTargets.length > 2) {\n      //The maximum number of semantics is 2 when there is LABEL, otherwise it is 1\n      throw new Error('Invalid combination of semantics. A maximum of 2 semantics are allowed only if the label is present, otherwise only 1.');\n    }\n\n    const hasMultipleChoice = semantics.some((item) => item.hasAttribute('multiple'));\n\n    //most of attrs validation (related to semantics), is made by CSS (except for expanded/compact, only for selection choice and target, only if target semantics is in)\n    const graphics = children\n      .filter((item) => item.tagName.toLowerCase() === _utilities_dictionary_map__WEBPACK_IMPORTED_MODULE_0__[\"GRAPHICS\"]);\n    const graphicAttrs = graphics.map((item) => item.getAttributeNames()).flat();\n\n    //Expanded management (only for selection choice)\n    if (graphicAttrs.includes('expanded') && !semanticTargets.includes(_utilities_dictionary_map__WEBPACK_IMPORTED_MODULE_0__[\"SELECTION_CHOICE\"]) && !semanticTargets.includes(_utilities_dictionary_map__WEBPACK_IMPORTED_MODULE_0__[\"DATA_ACQUISITION\"])) {\n      throw new Error('Graphic component \"expanded\" is not allowed with this semantics.');\n    }\n\n    //Value management for selection choice: value is valid only if the expanded graphic component is in\n    if (semanticTargets.includes(_utilities_dictionary_map__WEBPACK_IMPORTED_MODULE_0__[\"SELECTION_CHOICE\"])) {\n      if (semanticsAttrs.includes('value') && (!graphicAttrs.includes('expanded') || hasMultipleChoice)) {\n        throw new Error('Invalid combination: only expanded single selection-choice must have \"value\" attribute.');\n      }\n      if (!semanticsAttrs.includes('value') && (graphicAttrs.includes('expanded') && !hasMultipleChoice)) {\n        throw new Error('Invalid combination: expanded single selection-choice must have \"value\" attribute.');\n      }\n    }\n\n    //Graphic target (semantics) validation\n    const graphicTargets = graphicAttrs.includes('target') && graphics.reduce((accumulator, item) => {\n      const target = item.getAttribute('target');\n      return target ? [ ...accumulator, target ] : accumulator;\n    }, []);\n\n    //Is the target semantics in the graphic component valid?\n    const hasValidTargetSemantics = graphicTargets ? \n      graphicTargets.reduce((accumulator, item) => \n        _utilities_dictionary_map__WEBPACK_IMPORTED_MODULE_0__[\"semantics\"].some((semantics) => item.includes(semantics)) && accumulator, true) : \n      true;\n    //Is the target semantics in?\n    const isTargetSemanticsIn = graphicTargets ? semanticTargets.reduce((accumulator, item) => graphicTargets.includes(item) || accumulator, false) : true;\n\n    if (graphicTargets && (!hasValidTargetSemantics || !isTargetSemanticsIn)) {\n      throw new Error('Invalid target semantics.');\n    }\n\n    //Vocal validation\n    const vocal = children\n      .filter((item) => item.tagName.toLowerCase() === _utilities_dictionary_map__WEBPACK_IMPORTED_MODULE_0__[\"VOCAL\"]);\n\n    const hasCleanEvent = vocal.some((item) => item.getAttribute('event') === 'clean');\n    if (!semanticTargets.includes('data-acquisition') && hasCleanEvent) {\n      throw new Error('\"Clean\" event is available only for data-acquisition semantics.');\n    }\n\n    const hasOpenEvent = vocal.some((item) => item.getAttribute('event') === 'open');\n    const hasExpandedAttr = graphicAttrs.includes('expanded');\n    if (!semanticTargets.includes('selection-choice') && !hasExpandedAttr && hasOpenEvent) {\n      throw new Error('\"Open\" event is available only for expanded selection-choice semantics.');\n    }\n\n    return true;\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Widget);\n\n//# sourceURL=webpack:///./js/components/widget.js?");

/***/ }),

/***/ "./js/main.js":
/*!********************!*\
  !*** ./js/main.js ***!
  \********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components */ \"./js/components/index.js\");\n\n\ndocument.addEventListener('DOMContentLoaded', () => {\n    customElements.define('widget-container', _components__WEBPACK_IMPORTED_MODULE_0__[\"Widget\"]);\n    customElements.define('widget-semantic', _components__WEBPACK_IMPORTED_MODULE_0__[\"Semantics\"]);\n    customElements.define('widget-vocal', _components__WEBPACK_IMPORTED_MODULE_0__[\"Vocal\"]);\n    customElements.define('widget-graphic', _components__WEBPACK_IMPORTED_MODULE_0__[\"Graphics\"]);\n});\n\n//# sourceURL=webpack:///./js/main.js?");

/***/ }),

/***/ "./js/utilities/dictionary/index.js":
/*!******************************************!*\
  !*** ./js/utilities/dictionary/index.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _prototypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./prototypes */ \"./js/utilities/dictionary/prototypes.js\");\n/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./map */ \"./js/utilities/dictionary/map.js\");\n\n\n\n/**\n * Dictionary with library prototypes used after components validation.\n * @function\n * @param {object} param0 Attributes for choosing the correct prototype\n * @param {string} param0.type Button type/input type\n * @param {boolean} param0.expanded Flag for compact or expanded view\n * @param {boolean} param0.multiple Flag for multiple or single choice, both compact and expanded\n * @param {string} param0.to Link \"to\" for navigating\n * @param {string} param0.value Value for expanded choice/option in case of compact choice (both multiple and single)\n * @param {string} param0.text Label text\n * @param {string} param0.element Reference to the element (e.g. label \"for\" attribute)\n * @param {boolean} param0.disabled Disabled flag\n * @param {boolean} param0.checked Checked flag\n * @param {boolean} param0.required Required flag\n * @param {boolean} param0.readonly Readonly flag\n * @param {boolean} param0.selected Selected flag\n * @param {string} param0.name Name attribute\n */\nconst dictionary = (semantics, { type, expanded, multiple, to, value, text, element, disabled, checked, required, readonly, selected, name }) => {\n    //Before this function call, the validator has already checked the parameters provided by the user via html\n    switch(semantics) {\n        case _map__WEBPACK_IMPORTED_MODULE_1__[\"SINGLE_CHOICE\"]: \n            return new _prototypes__WEBPACK_IMPORTED_MODULE_0__[\"SingleChoice\"]({ type, text, disabled, value, name, element });\n        case _map__WEBPACK_IMPORTED_MODULE_1__[\"SELECTION_CHOICE\"]: \n            return new _prototypes__WEBPACK_IMPORTED_MODULE_0__[\"SelectionChoice\"]({ expanded, multiple, element, value, disabled, checked, required, name });\n        case _map__WEBPACK_IMPORTED_MODULE_1__[\"DATA_ACQUISITION\"]: \n            return new _prototypes__WEBPACK_IMPORTED_MODULE_0__[\"DataAcquisition\"]({ type, expanded, element, disabled, required, readonly, value, name });\n        case _map__WEBPACK_IMPORTED_MODULE_1__[\"NAVIGATION\"]: \n            return new _prototypes__WEBPACK_IMPORTED_MODULE_0__[\"Navigation\"]({ to, text, element });\n        case _map__WEBPACK_IMPORTED_MODULE_1__[\"LABEL\"]: \n            return new _prototypes__WEBPACK_IMPORTED_MODULE_0__[\"Label\"]({ text, element });\n        case _map__WEBPACK_IMPORTED_MODULE_1__[\"OPTION\"]: \n            return new _prototypes__WEBPACK_IMPORTED_MODULE_0__[\"Option\"]({ value, text, disabled, selected });\n        default:\n            throw new Error('Invalid semantics.');\n    };\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (dictionary);\n\n\n//# sourceURL=webpack:///./js/utilities/dictionary/index.js?");

/***/ }),

/***/ "./js/utilities/dictionary/map.js":
/*!****************************************!*\
  !*** ./js/utilities/dictionary/map.js ***!
  \****************************************/
/*! exports provided: CONTAINER, SEMANTICS, GRAPHICS, VOCAL, SINGLE_CHOICE, SELECTION_CHOICE, DATA_ACQUISITION, NAVIGATION, LABEL, OPTION, semantics, singleChoiceTypes, dataAcquisitionTypes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CONTAINER\", function() { return CONTAINER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SEMANTICS\", function() { return SEMANTICS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GRAPHICS\", function() { return GRAPHICS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VOCAL\", function() { return VOCAL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SINGLE_CHOICE\", function() { return SINGLE_CHOICE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SELECTION_CHOICE\", function() { return SELECTION_CHOICE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DATA_ACQUISITION\", function() { return DATA_ACQUISITION; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NAVIGATION\", function() { return NAVIGATION; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LABEL\", function() { return LABEL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OPTION\", function() { return OPTION; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"semantics\", function() { return semantics; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"singleChoiceTypes\", function() { return singleChoiceTypes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dataAcquisitionTypes\", function() { return dataAcquisitionTypes; });\n/**\n * Widget container\n * @constant\n */\nconst CONTAINER = 'widget-container';\n/**\n * Semantics component\n * @constant\n */\nconst SEMANTICS = 'widget-semantic';\n/**\n * Graphics component\n * @constant\n */\nconst GRAPHICS = 'widget-graphic';\n/**\n * Vocal component\n * @constant\n */\nconst VOCAL = 'widget-vocal';\n/** \n * Single choice prototype (button)\n * @constant\n */\nconst SINGLE_CHOICE = 'single-choice';\n/** \n * Selection choice prototype (select, multiselect, checkbox and radio button)\n * @constant\n */\nconst SELECTION_CHOICE = 'selection-choice';\n/** \n * Data acquisition prototype (each type of input tag + textarea)\n * @constant\n */\nconst DATA_ACQUISITION = 'data-acquisition';\n/** \n * Navigation prototype (links)\n * @constant\n */\nconst NAVIGATION = 'navigation';\n/** \n * Label prototype\n * @constant\n */\nconst LABEL = 'label';\n/** \n * Option prototype (related to each kind of selection choice)\n * @constant\n */\nconst OPTION = 'option';\n\nconst semantics = [ SINGLE_CHOICE, SELECTION_CHOICE, LABEL, OPTION, NAVIGATION, DATA_ACQUISITION ];\n\nconst singleChoiceTypes = [ 'submit', 'reset', 'button' ];\nconst dataAcquisitionTypes = [ \n    'text', \n    'color', \n    'date', \n    'datetime', \n    'datetime-local', \n    'email', \n    'file', \n    'image', \n    'month', \n    'number', \n    'password', \n    'range', \n    'search', \n    'tel', \n    'text', \n    'time', \n    'url', \n    'week'\n];\n\n\n\n//# sourceURL=webpack:///./js/utilities/dictionary/map.js?");

/***/ }),

/***/ "./js/utilities/dictionary/prototypes.js":
/*!***********************************************!*\
  !*** ./js/utilities/dictionary/prototypes.js ***!
  \***********************************************/
/*! exports provided: SingleChoice, SelectionChoice, DataAcquisition, Navigation, Label, Option */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SingleChoice\", function() { return SingleChoice; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SelectionChoice\", function() { return SelectionChoice; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DataAcquisition\", function() { return DataAcquisition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Navigation\", function() { return Navigation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Label\", function() { return Label; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Option\", function() { return Option; });\n//This file contains semantics prototypes according to our abstract definition\n//These prototypes can be used by the validator function\n//to return an object containing the tag and attributes based on the input semantics\n\n/**\n * Base prototype having the HTML tag property.\n * @constructor\n * @param {object} pram0 Base element parameters\n * @param {string} param0.tag HTML tag\n * @param {boolean} param0.disabled Disabled flag\n */\nfunction BaseElement ({ tag, disabled }) {\n    this.tag = tag;\n    this.disabled = disabled;\n};\n\n/**\n * SingleChoice prototype represents the button element.\n * This prototype uses the composition pattern (BaseElement prototype).\n * @constructor\n * @param {object} param0 SingleChoice parameters for tag name and button type \n * @param {string} param0.tag HTML tag\n * @param {string} param0.type Button type\n * @param {string} param0.text Button label\n * @param {boolean} param0.disabled Disabled flag\n * @param {string} param0.value Value attribute\n * @param {string} param0.name Name attribute\n * @param {string} param0.element Element ID\n */\nfunction SingleChoice ({ tag = 'button', type = 'submit', text, disabled, value, name, element }) {\n    //Single choice is button tag. The type attribute is implicitly \"submit\", but it can be also \"reset\" or \"button\".\n    BaseElement.call(this, { tag, disabled: Boolean(disabled) }); //a kind of composition: with or without BaseElement extension, SingleChoice has the tag attribute\n\n    this.type = type;\n    this.innerText = text;\n\n    if (value) {\n        this.value = value;\n    }\n\n    if (element) {\n        this.id = element;\n    }\n    if (name) {\n        this.name = name;\n    }\n};\n\n/**\n * SelectionChoice prototype represet each kind of selection, such as single and multiple select and checkbox and radio button.\n * This prototype uses the composition pattern (BaseElement prototype).\n * @constructor\n * @param {object} param0 SelectionChoice parameters\n * @param {boolean} param0.expanded Expanded flag for compact or expanded widget\n * @param {boolean} param0.multiple Multiple or single flag for selection choice (select/multiselect for compact parameter true, radio/checkbox for compact parameter false)\n * @param {string} param0.element Identifier\n * @param {boolean} param0.checked Checked flag\n * @param {boolean} param0.disabled Disabled flag\n * @param {boolean} param0.required Required flag\n * @param {string} param0.name Name attribute\n */\nfunction SelectionChoice ({ expanded, multiple, element, value, checked, disabled, required, name }) {\n    const tag = expanded? 'input' : 'select';\n\n    BaseElement.call(this, { tag, disabled: Boolean(disabled) });\n\n    if (expanded && multiple) {\n        this.type = 'checkbox'; //type attribute in input\n        this.checked = Boolean(checked);\n    }\n\n    if (expanded && !multiple) {\n        this.type = 'radio'; //type attribute in input\n        this.value = value;\n    }\n    \n    if (!expanded && multiple) {\n        this.multiple = true; //multiple attribute in select\n    }\n\n    this.required = Boolean(required);\n\n    if (element) {\n        this.id = element;\n    }\n    if (name) {\n        this.name = name;\n    }\n};\n\n/**\n * Prototype for data acquisition, such as number, color, date, datetime.\n * This prototype uses composition (BaseElement prototype).\n * @constructor\n * @param {object} param0 DataAcquisition parameters\n * @param {string} param0.type Data type to acquire\n * @param {boolean} param0.expanded Expanded flag for choosing between input or textarea\n * @param {string} param0.element Identifier\n * @param {boolean} param0.disabled Disabled flag\n * @param {boolean} param0.required Required flag\n * @param {boolean} param0.readonly Readonly flag\n * @param {string} param0.value Value attribute\n * @param {string} param0.name Name attribute\n */\nfunction DataAcquisition ({ type = 'text', expanded, element, disabled, required, readonly, value, name }) {\n    let tag = 'textarea';\n\n    if(!expanded) {\n        tag = 'input';\n        this.type = type;\n    }\n\n    if (value) {\n        this.value = value;\n    }\n\n    this.required = Boolean(required);\n    this.readOnly = Boolean(readonly);\n\n    BaseElement.call(this, { tag, disabled: Boolean(disabled) });\n\n    if (element) {\n        this.id = element;\n    }\n    if (name) {\n        this.name = name;\n    }\n};\n\n/**\n * Prototype for navigation.\n * This prototype uses composition (BaseElement prototype).\n * @constructor\n * @param {object} param0 Navigation semantics parameters\n * @param {string} param0.to Link for navigation\n * @param {string} param0.text Link label\n * @param {string} param0.element Element ID\n */\nfunction Navigation ({ to, text, element }) {\n    BaseElement.call(this, { tag: 'a' });\n\n    this.href = to;\n    this.innerText = text\n\n    if (element) {\n        this.id = element;\n    }\n};\n\n/**\n * Prototype for label, used for SingleChoice, SelectionChoice, DataAcquisition, Navigation.\n * @constructor\n * @param {object} param0 Label parameters\n * @param {string} param0.text Label content\n * @param {string} param0.element Element identifier\n */\nfunction Label ({ text, element }) {\n    BaseElement.call(this, { tag: 'label' });\n\n    this.innerText = text;\n    this.htmlFor = element;\n};\n\n/**\n * Prototype for single option, used for SelectionChoice.\n * @constructor\n * @param {object} param0 Option parameter\n * @param {string} param0.value Option value, used also as label\n * @param {string} param0.text Label content\n * @param {boolean} param0.disabled Disabled flag\n * @param {boolean} param0.selected Selected flag\n */\nfunction Option ({ value, text, disabled, selected }) {\n    BaseElement.call(this, { tag: 'option', disabled: Boolean(disabled) });\n\n    this.selected = Boolean(selected);\n    this.value = value;\n    this.innerText = text;\n};\n\n\n\n\n//# sourceURL=webpack:///./js/utilities/dictionary/prototypes.js?");

/***/ }),

/***/ "./js/utilities/graphics/index.js":
/*!****************************************!*\
  !*** ./js/utilities/graphics/index.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map */ \"./js/utilities/graphics/map.js\");\n\n\n/**\n * Map parameters to CSS property.\n * \n * @param {string} graphicComponent Property of graphic component\n * @param {string} value Value specified in the graphic component\n * @param {string} target HTML tag\n */\nconst getTranslatedCSSPropery = (graphicComponent, value, target) => {\n    switch (graphicComponent) {\n        case _map__WEBPACK_IMPORTED_MODULE_0__[\"SIZE\"]:\n            const factor = _map__WEBPACK_IMPORTED_MODULE_0__[\"scaleValues\"][value];\n            return `padding: ${factor}em`;\n        case _map__WEBPACK_IMPORTED_MODULE_0__[\"SHADOW\"]:\n            return `${_map__WEBPACK_IMPORTED_MODULE_0__[\"getShadowProperty\"](target)}: ${value};`;\n        case _map__WEBPACK_IMPORTED_MODULE_0__[\"COLOR\"]:\n        case _map__WEBPACK_IMPORTED_MODULE_0__[\"BACKGROUND\"]:\n        case _map__WEBPACK_IMPORTED_MODULE_0__[\"BORDER\"]:\n        case _map__WEBPACK_IMPORTED_MODULE_0__[\"FONT\"]:\n            return `${graphicComponent}: ${value}`;\n        default:\n            throw new Error('Invalid graphics.');\n    };\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (getTranslatedCSSPropery);\n\n//# sourceURL=webpack:///./js/utilities/graphics/index.js?");

/***/ }),

/***/ "./js/utilities/graphics/map.js":
/*!**************************************!*\
  !*** ./js/utilities/graphics/map.js ***!
  \**************************************/
/*! exports provided: COLOR, BACKGROUND, SIZE, BORDER, FONT, SHADOW, LARGE, MEDIUM, SMALL, scaleValues, getShadowProperty */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"COLOR\", function() { return COLOR; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BACKGROUND\", function() { return BACKGROUND; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SIZE\", function() { return SIZE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BORDER\", function() { return BORDER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FONT\", function() { return FONT; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SHADOW\", function() { return SHADOW; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LARGE\", function() { return LARGE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MEDIUM\", function() { return MEDIUM; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SMALL\", function() { return SMALL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scaleValues\", function() { return scaleValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getShadowProperty\", function() { return getShadowProperty; });\n/**\n * Text color, same as CSS property\n * @constant\n */\nconst COLOR = 'color';\n/**\n * Background color, same as CSS property\n * @constant\n */\nconst BACKGROUND = 'background';\n/**\n * Element size, one of SMALL, MEDIUM, LARGE\n * @constant\n */\nconst SIZE = 'size';\n/**\n * Element border, same as CSS property\n */\nconst BORDER = 'border';\n/**\n * Font\n * @constant\n */\nconst FONT = 'font';\n/**\n * Box shadow\n * @constant\n */\nconst SHADOW = 'shadow';\n/**\n * Size value LARGE\n * @constant\n */\nconst LARGE = 'large';\n/**\n * Size value MEDIUM\n * @constant\n */\nconst MEDIUM = 'medium';\n/**\n * Size value SMALL\n * @constant\n */\nconst SMALL = 'small';\n\n/**\n * Map for size values\n */\nconst scaleValues = {\n    [SMALL]: 0,\n    [MEDIUM]: 0.25,\n    [LARGE]: 0.5\n};\n\n/**\n * Shadow property translation based on target element.\n * \n * @param {string} target HTML element tag \n * @returns {string} Shadow property, one of 'text-shadow', 'box-shadow'\n */\nconst getShadowProperty = (target) => {\n    switch (target) {\n        case 'label':\n        case 'a':\n            return 'text-shadow';\n        default:\n            return 'box-shadow';\n    }\n};\n\n\n\n//# sourceURL=webpack:///./js/utilities/graphics/map.js?");

/***/ }),

/***/ "./js/utilities/vocal/index.js":
/*!*************************************!*\
  !*** ./js/utilities/vocal/index.js ***!
  \*************************************/
/*! exports provided: vocalInstance, addKeyword */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"vocalInstance\", function() { return vocalInstance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addKeyword\", function() { return addKeyword; });\n/* harmony import */ var artyom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! artyom.js */ \"./node_modules/artyom.js/build/artyom.js\");\n/* harmony import */ var artyom_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(artyom_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./map */ \"./js/utilities/vocal/map.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"./js/utilities/vocal/utils.js\");\n\n\n\n\n\nconst vocalInstance = new artyom_js__WEBPACK_IMPORTED_MODULE_0___default.a();\n\n//TODO: remove this, it is only for debug purpose\nwindow.artyom = vocalInstance;\n//artyom.simulateInstruction('...');\n\n/**\n * Add command based on parameters.\n * \n * @param {string} event HTML DOM event\n * @param {string} keyword Trigger word\n * @param {string} ref Attribute \"element\" in the widget\n * @param {string} semantics Semantics component type in the widget\n * @param {string} element HTML event\n */\nconst addKeyword = (event, keyword, ref, semantics, element) => {\n    const { command, isSmart } = Object(_map__WEBPACK_IMPORTED_MODULE_1__[\"createCommand\"])(keyword, ref, semantics, element);\n    \n    vocalInstance.on([ command ], isSmart).then((i, wildcard) => {\n        if (!element.hasAttribute('disabled') && !element.hasAttribute('readonly')) {\n            Object(_map__WEBPACK_IMPORTED_MODULE_1__[\"executeCommand\"])(event, wildcard, element);\n        }\n    });\n};\n\n/**\n * Artyom initialization.\n */\nvocalInstance.initialize({\n    lang: \"en-GB\", // GreatBritain english\n    continuous: true, // Listen forever\n    soundex: true,// Use the soundex algorithm to increase accuracy\n    listen: true, // Start to listen commands !\n}).then(() => {\n    Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_map__WEBPACK_IMPORTED_MODULE_1__[\"status\"]['READY']);\n}).catch((err) => {\n    Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_map__WEBPACK_IMPORTED_MODULE_1__[\"status\"]['ERROR']);\n});\n\n/**\n * Vocal feedbacks based on Artyom events.\n */\n/*vocalInstance.when('ERROR', (error) => {\n    console.log(error);\n    \n    const vocalFeedback = document.querySelector('#vocal-feedback');\n    vocalFeedback && document.body.removeChild(vocalFeedback);\n\n    createFeedbackObject(status['ERROR']);\n});*/\nvocalInstance.when('COMMAND_RECOGNITION_START', () => {\n    setTimeout(() => {\n        const vocalFeedback = document.querySelector('#vocal-feedback');\n        vocalFeedback && document.body.removeChild(vocalFeedback);\n        Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_map__WEBPACK_IMPORTED_MODULE_1__[\"status\"]['READY']);\n    }, 10000);\n});\nvocalInstance.when('TEXT_RECOGNIZED', () => {\n    const vocalFeedback = document.querySelector('#vocal-feedback');\n    vocalFeedback && document.body.removeChild(vocalFeedback);\n\n    Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_map__WEBPACK_IMPORTED_MODULE_1__[\"status\"]['LISTENING']);\n});\nvocalInstance.when('COMMAND_MATCHED', () => {\n    const vocalFeedback = document.querySelector('#vocal-feedback');\n    vocalFeedback && document.body.removeChild(vocalFeedback);\n\n    Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_map__WEBPACK_IMPORTED_MODULE_1__[\"status\"]['MATCHED']);\n});\nvocalInstance.when('NOT_COMMAND_MATCHED', () => {\n    const vocalFeedback = document.querySelector('#vocal-feedback');\n    vocalFeedback && document.body.removeChild(vocalFeedback);\n\n    Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_map__WEBPACK_IMPORTED_MODULE_1__[\"status\"]['NOT_MATCHED']);\n});\n\n\n\n\n//# sourceURL=webpack:///./js/utilities/vocal/index.js?");

/***/ }),

/***/ "./js/utilities/vocal/map.js":
/*!***********************************!*\
  !*** ./js/utilities/vocal/map.js ***!
  \***********************************/
/*! exports provided: createCommand, executeCommand, status, events */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createCommand\", function() { return createCommand; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"executeCommand\", function() { return executeCommand; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"status\", function() { return status; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"events\", function() { return events; });\n/* harmony import */ var _dictionary_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dictionary/map */ \"./js/utilities/dictionary/map.js\");\n/* harmony import */ var _vocal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../vocal */ \"./js/utilities/vocal/index.js\");\n\n\n\nconst events = [\n    'blur',\n    'change',\n    'click',\n    'focus',\n    'input',\n    'clean',\n    'open'\n];\n\n/**\n * Map parameters to vocal command.\n * \n * @param {string} keyword Command trigger\n * @param {string} ref Element reference\n * @param {string} semantics Referred element semantics\n * @param {string} element HTML Element\n */\nconst createCommand = (keyword, ref = '', semantics, element) => {\n    switch (semantics) {\n        case _dictionary_map__WEBPACK_IMPORTED_MODULE_0__[\"SINGLE_CHOICE\"]:\n        case _dictionary_map__WEBPACK_IMPORTED_MODULE_0__[\"NAVIGATION\"]:\n            return {\n                command: `${keyword} ${ref}`,\n                isSmart: false\n            };\n        case _dictionary_map__WEBPACK_IMPORTED_MODULE_0__[\"DATA_ACQUISITION\"]:\n            return {\n                command: `${keyword} * in ${ref}`,\n                isSmart: true\n            };\n        case _dictionary_map__WEBPACK_IMPORTED_MODULE_0__[\"SELECTION_CHOICE\"]:\n            if (element.type === 'checkbox' || element.type === 'radio') {\n                return {\n                    command: `${keyword} ${ref}`,\n                    isSmart: false\n                };\n            } else {\n                return {\n                    command: `${keyword} * from ${ref}`,\n                    isSmart: true\n                };\n            }\n        default:\n            throw new Error('Invalid semantics.');\n    };\n};\n\n/**\n * Map parameters to command to execute\n * @param {string} event Event to emit\n * @param {string} wildcard Option/text pronounced by the user\n * @param {string} element HTML Element\n */\nconst executeCommand = (event, wildcard, element) => {\n    switch (event) {\n        case 'open':\n            _vocal__WEBPACK_IMPORTED_MODULE_1__[\"vocalInstance\"].say(`You can select... ${[...element.options].reduce((accumulator, option) => accumulator + '..., ' + option.value, '')}.`);\n            break;\n        case 'click':\n            element.click();\n            break;\n        case 'blur':\n            element.blur();\n            break;\n        case 'focus':\n            element.focus();\n            break;\n        case 'change':\n        case 'input':\n            console.log(element)\n            if (element.type === 'text' || element.tagName.toLowerCase() === 'textarea') {\n                element.value = wildcard;\n            } else if (element.type === 'checkbox' || element.type === 'radio') {\n                element.checked = !element.checked;\n            } else {\n                //mapping options/labels\n                const mapping = [...element.options].reduce((accumulator, option) => ({\n                    ...accumulator,\n                    [option.innerText.toLowerCase()]: option.value\n                }), {});\n\n                element.value = mapping[wildcard];\n            }\n            element.dispatchEvent(new Event(event));\n            break;\n        case 'clean':\n            element.value = '';\n            element.dispatchEvent(new Event(event));\n            break;\n        default:\n            throw new Error('Invalid event.');\n    };\n};\n\nconst READY = {\n    text: 'Ready!',\n};\nconst LISTENING = {\n    text: 'Listening...',\n    status:\n        `<svg height=\"24\" width=\"24\">\n            <circle cx=\"12\" cy=\"12\" r=\"6\" fill=\"red\" />\n        </svg>`\n};\nconst MATCHED = {\n    text: 'Command matched!',\n    status:\n        `<svg height=\"24\" width=\"24\">\n            <line x1=\"4\" y1=\"12\" x2=\"8\" y2=\"20\" stroke=\"green\" stroke-width=\"3\" stroke-linecap=\"round\"></line>\n            <line x1=\"20\" y1=\"4\" x2=\"8\" y2=\"20\" stroke=\"green\" stroke-width=\"3\" stroke-linecap=\"round\"></line>\n        </svg>`\n};\nconst NOT_MATCHED = {\n    text: 'Command not matched.',\n    status:\n        `<svg height=\"24\" width=\"24\">\n            <line x1=\"4\" y1=\"4\" x2=\"20\" y2=\"20\" stroke=\"red\" stroke-width=\"3\" stroke-linecap=\"round\"></line>\n            <line x1=\"20\" y1=\"4\" x2=\"4\" y2=\"20\" stroke=\"red\" stroke-width=\"3\" stroke-linecap=\"round\"></line>\n        </svg>`\n};\nconst ERROR = {\n    text: 'Voice commands not available.',\n    status:\n        `<svg height=\"24\" width=\"24\">\n            <line x1=\"12\" y1=\"4\" x2=\"12\" y2=\"16\" stroke=\"red\" stroke-width=\"3\" stroke-linecap=\"round\"></line>\n            <line x1=\"12\" y1=\"22\" x2=\"12\" y2=\"22\" stroke=\"red\" stroke-width=\"3\" stroke-linecap=\"round\"></line>\n        </svg>`\n}\n\n/**\n * Vocal commands recognition status\n * @constant\n */\nconst status = {\n    READY,\n    LISTENING,\n    MATCHED,\n    NOT_MATCHED,\n    ERROR\n}\n\n\n\n//# sourceURL=webpack:///./js/utilities/vocal/map.js?");

/***/ }),

/***/ "./js/utilities/vocal/utils.js":
/*!*************************************!*\
  !*** ./js/utilities/vocal/utils.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n * Creates vocal feedback.\n * \n * @param {{text: string, status: string}} param0\n * @param {string} param0.text Status text\n * @param {string} param0.status Status icon, HTML string \n */\nconst createFeedbackObject = ({ text, status }) => {\n    const container = document.createElement('div');\n\n    if (status) {\n        container.innerHTML = status;\n    }\n\n    const caption = document.createElement('span');\n    caption.innerText = text;\n    caption.style.verticalAlign = 'super';\n    caption.style.fontFamily = 'sans-serif';\n    caption.style.fontSize = '1.25rem';\n\n    container.appendChild(caption);\n\n    container.style.position = 'fixed';\n    container.style.bottom = '10px';\n    container.style.right = '10px';\n    container.id = 'vocal-feedback';\n\n    document.body.appendChild(container);\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (createFeedbackObject);\n\n//# sourceURL=webpack:///./js/utilities/vocal/utils.js?");

/***/ }),

/***/ "./node_modules/artyom.js/build/artyom.js":
/*!************************************************!*\
  !*** ./node_modules/artyom.js/build/artyom.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n/**\r\n * Artyom.js is a voice control, speech recognition and speech synthesis JavaScript library.\r\n *\r\n * @requires {webkitSpeechRecognition && speechSynthesis}\r\n * @license MIT\r\n * @version 1.0.6\r\n * @copyright 2017 Our Code World (www.ourcodeworld.com) All Rights Reserved.\r\n * @author Carlos Delgado (https://github.com/sdkcarlos) and Sema García (https://github.com/semagarcia)\r\n * @see https://sdkcarlos.github.io/sites/artyom.html\r\n * @see http://docs.ourcodeworld.com/projects/artyom-js\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/// <reference path=\"artyom.d.ts\" />\r\n// Remove \"export default \" keywords if willing to build with `npm run artyom-build-window`\r\nvar Artyom = (function () {\r\n    // Triggered at the declaration of \r\n    function Artyom() {\r\n        this.ArtyomCommands = [];\r\n        this.ArtyomVoicesIdentifiers = {\r\n            // German\r\n            \"de-DE\": [\"Google Deutsch\", \"de-DE\", \"de_DE\"],\r\n            // Spanish\r\n            \"es-ES\": [\"Google español\", \"es-ES\", \"es_ES\", \"es-MX\", \"es_MX\"],\r\n            // Italian\r\n            \"it-IT\": [\"Google italiano\", \"it-IT\", \"it_IT\"],\r\n            // Japanese\r\n            \"jp-JP\": [\"Google 日本人\", \"ja-JP\", \"ja_JP\"],\r\n            // English USA\r\n            \"en-US\": [\"Google US English\", \"en-US\", \"en_US\"],\r\n            // English UK\r\n            \"en-GB\": [\"Google UK English Male\", \"Google UK English Female\", \"en-GB\", \"en_GB\"],\r\n            // Brazilian Portuguese\r\n            \"pt-BR\": [\"Google português do Brasil\", \"pt-PT\", \"pt-BR\", \"pt_PT\", \"pt_BR\"],\r\n            // Portugal Portuguese\r\n            // Note: in desktop, there's no voice for portugal Portuguese\r\n            \"pt-PT\": [\"Google português do Brasil\", \"pt-PT\", \"pt_PT\"],\r\n            // Russian\r\n            \"ru-RU\": [\"Google русский\", \"ru-RU\", \"ru_RU\"],\r\n            // Dutch (holland)\r\n            \"nl-NL\": [\"Google Nederlands\", \"nl-NL\", \"nl_NL\"],\r\n            // French\r\n            \"fr-FR\": [\"Google français\", \"fr-FR\", \"fr_FR\"],\r\n            // Polish\r\n            \"pl-PL\": [\"Google polski\", \"pl-PL\", \"pl_PL\"],\r\n            // Indonesian\r\n            \"id-ID\": [\"Google Bahasa Indonesia\", \"id-ID\", \"id_ID\"],\r\n            // Hindi\r\n            \"hi-IN\": [\"Google हिन्दी\", \"hi-IN\", \"hi_IN\"],\r\n            // Mandarin Chinese\r\n            \"zh-CN\": [\"Google 普通话（中国大陆）\", \"zh-CN\", \"zh_CN\"],\r\n            // Cantonese Chinese\r\n            \"zh-HK\": [\"Google 粤語（香港）\", \"zh-HK\", \"zh_HK\"],\r\n            // Native voice\r\n            \"native\": [\"native\"]\r\n        };\r\n        // Important: retrieve the voices of the browser as soon as possible.\r\n        // Normally, the execution of speechSynthesis.getVoices will return at the first time an empty array.\r\n        if (window.hasOwnProperty('speechSynthesis')) {\r\n            speechSynthesis.getVoices();\r\n        }\r\n        else {\r\n            console.error(\"Artyom.js can't speak without the Speech Synthesis API.\");\r\n        }\r\n        // This instance of webkitSpeechRecognition is the one used by Artyom.\r\n        if (window.hasOwnProperty('webkitSpeechRecognition')) {\r\n            this.ArtyomWebkitSpeechRecognition = new window.webkitSpeechRecognition();\r\n        }\r\n        else {\r\n            console.error(\"Artyom.js can't recognize voice without the Speech Recognition API.\");\r\n        }\r\n        this.ArtyomProperties = {\r\n            lang: 'en-GB',\r\n            recognizing: false,\r\n            continuous: false,\r\n            speed: 1,\r\n            volume: 1,\r\n            listen: false,\r\n            mode: \"normal\",\r\n            debug: false,\r\n            helpers: {\r\n                redirectRecognizedTextOutput: null,\r\n                remoteProcessorHandler: null,\r\n                lastSay: null,\r\n                fatalityPromiseCallback: null\r\n            },\r\n            executionKeyword: null,\r\n            obeyKeyword: null,\r\n            speaking: false,\r\n            obeying: true,\r\n            soundex: false,\r\n            name: null\r\n        };\r\n        this.ArtyomGarbageCollection = [];\r\n        this.ArtyomFlags = {\r\n            restartRecognition: false\r\n        };\r\n        this.ArtyomGlobalEvents = {\r\n            ERROR: \"ERROR\",\r\n            SPEECH_SYNTHESIS_START: \"SPEECH_SYNTHESIS_START\",\r\n            SPEECH_SYNTHESIS_END: \"SPEECH_SYNTHESIS_END\",\r\n            TEXT_RECOGNIZED: \"TEXT_RECOGNIZED\",\r\n            COMMAND_RECOGNITION_START: \"COMMAND_RECOGNITION_START\",\r\n            COMMAND_RECOGNITION_END: \"COMMAND_RECOGNITION_END\",\r\n            COMMAND_MATCHED: \"COMMAND_MATCHED\",\r\n            NOT_COMMAND_MATCHED: \"NOT_COMMAND_MATCHED\"\r\n        };\r\n        this.Device = {\r\n            isMobile: false,\r\n            isChrome: true\r\n        };\r\n        if (navigator.userAgent.match(/Android/i) || navigator.userAgent.match(/webOS/i) || navigator.userAgent.match(/iPhone/i) || navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPod/i) || navigator.userAgent.match(/BlackBerry/i) || navigator.userAgent.match(/Windows Phone/i)) {\r\n            this.Device.isMobile = true;\r\n        }\r\n        if (navigator.userAgent.indexOf(\"Chrome\") == -1) {\r\n            this.Device.isChrome = false;\r\n        }\r\n        /**\r\n         * The default voice of Artyom in the Desktop. In mobile, you will need to initialize (or force the language)\r\n         * with a language code in order to find an available voice in the device, otherwise it will use the native voice.\r\n         */\r\n        this.ArtyomVoice = {\r\n            default: false,\r\n            lang: \"en-GB\",\r\n            localService: false,\r\n            name: \"Google UK English Male\",\r\n            voiceURI: \"Google UK English Male\"\r\n        };\r\n    }\r\n    /**\r\n     * Add dinamically commands to artyom using\r\n     * You can even add commands while artyom is active.\r\n     *\r\n     * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/addcommands\r\n     * @since 0.6\r\n     * @param {Object | Array[Objects]} param\r\n     * @returns {undefined}\r\n     */\r\n    Artyom.prototype.addCommands = function (param) {\r\n        var _this = this;\r\n        var processCommand = function (command) {\r\n            if (command.hasOwnProperty(\"indexes\")) {\r\n                _this.ArtyomCommands.push(command);\r\n            }\r\n            else {\r\n                console.error(\"The given command doesn't provide any index to execute.\");\r\n            }\r\n        };\r\n        if (param instanceof Array) {\r\n            for (var i = 0; i < param.length; i++) {\r\n                processCommand(param[i]);\r\n            }\r\n        }\r\n        else {\r\n            processCommand(param);\r\n        }\r\n        return true;\r\n    };\r\n    ;\r\n    /**\r\n     * The SpeechSynthesisUtterance objects are stored in the artyom_garbage_collector variable\r\n     * to prevent the wrong behaviour of artyom.say.\r\n     * Use this method to clear all spoken SpeechSynthesisUtterance unused objects.\r\n     *\r\n     * @returns {Array<any>}\r\n     */\r\n    Artyom.prototype.clearGarbageCollection = function () {\r\n        return this.ArtyomGarbageCollection = [];\r\n    };\r\n    ;\r\n    /**\r\n     * Displays a message in the console if the artyom propery DEBUG is set to true.\r\n     *\r\n     * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/debug\r\n     * @returns {undefined}\r\n     */\r\n    Artyom.prototype.debug = function (message, type) {\r\n        var preMessage = \"[v\" + this.getVersion() + \"] Artyom.js\";\r\n        if (this.ArtyomProperties.debug === true) {\r\n            switch (type) {\r\n                case \"error\":\r\n                    console.log(\"%c\" + preMessage + \":%c \" + message, 'background: #C12127; color: black;', 'color:black;');\r\n                    break;\r\n                case \"warn\":\r\n                    console.warn(message);\r\n                    break;\r\n                case \"info\":\r\n                    console.log(\"%c\" + preMessage + \":%c \" + message, 'background: #4285F4; color: #FFFFFF', 'color:black;');\r\n                    break;\r\n                default:\r\n                    console.log(\"%c\" + preMessage + \":%c \" + message, 'background: #005454; color: #BFF8F8', 'color:black;');\r\n                    break;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Artyom have it's own diagnostics.\r\n     * Run this function in order to detect why artyom is not initialized.\r\n     *\r\n     * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/detecterrors\r\n     * @param {type} callback\r\n     * @returns {}\r\n     */\r\n    Artyom.prototype.detectErrors = function () {\r\n        var _this = this;\r\n        if ((window.location.protocol) == \"file:\") {\r\n            var message = \"Error: running Artyom directly from a file. The APIs require a different communication protocol like HTTP or HTTPS\";\r\n            console.error(message);\r\n            return {\r\n                code: \"artyom_error_localfile\",\r\n                message: message\r\n            };\r\n        }\r\n        if (!_this.Device.isChrome) {\r\n            var message = \"Error: the Speech Recognition and Speech Synthesis APIs require the Google Chrome Browser to work.\";\r\n            console.error(message);\r\n            return {\r\n                code: \"artyom_error_browser_unsupported\",\r\n                message: message\r\n            };\r\n        }\r\n        if (window.location.protocol != \"https:\") {\r\n            console.warn(\"Warning: artyom is being executed using the '\" + window.location.protocol + \"' protocol. The continuous mode requires a secure protocol (HTTPS)\");\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * Removes all the added commands of artyom.\r\n     *\r\n     * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/emptycommands\r\n     * @since 0.6\r\n     * @returns {Array}\r\n     */\r\n    Artyom.prototype.emptyCommands = function () {\r\n        return this.ArtyomCommands = [];\r\n    };\r\n    /**\r\n     * Returns an object with data of the matched element\r\n     *\r\n     * @private\r\n     * @param {string} comando\r\n     * @returns {MatchedCommand}\r\n     */\r\n    Artyom.prototype.execute = function (voz) {\r\n        var _this = this;\r\n        if (!voz) {\r\n            console.warn(\"Internal error: Execution of empty command\");\r\n            return;\r\n        }\r\n        // If artyom was initialized with a name, verify that the name begins with it to allow the execution of commands.\r\n        if (_this.ArtyomProperties.name) {\r\n            if (voz.indexOf(_this.ArtyomProperties.name) != 0) {\r\n                _this.debug(\"Artyom requires with a name \\\"\" + _this.ArtyomProperties.name + \"\\\" but the name wasn't spoken.\", \"warn\");\r\n                return;\r\n            }\r\n            // Remove name from voice command\r\n            voz = voz.substr(_this.ArtyomProperties.name.length);\r\n        }\r\n        _this.debug(\">> \" + voz);\r\n        /** @3\r\n         * Artyom needs time to think that\r\n         */\r\n        for (var i = 0; i < _this.ArtyomCommands.length; i++) {\r\n            var instruction = _this.ArtyomCommands[i];\r\n            var opciones = instruction.indexes;\r\n            var encontrado = -1;\r\n            var wildy = \"\";\r\n            for (var c = 0; c < opciones.length; c++) {\r\n                var opcion = opciones[c];\r\n                if (!instruction.smart) {\r\n                    continue; //Jump if is not smart command\r\n                }\r\n                // Process RegExp\r\n                if (opcion instanceof RegExp) {\r\n                    // If RegExp matches \r\n                    if (opcion.test(voz)) {\r\n                        _this.debug(\">> REGEX \" + opcion.toString() + \" MATCHED AGAINST \" + voz + \" WITH INDEX \" + c + \" IN COMMAND \", \"info\");\r\n                        encontrado = parseInt(c.toString());\r\n                    }\r\n                    // Otherwise just wildcards\r\n                }\r\n                else {\r\n                    if (opcion.indexOf(\"*\") != -1) {\r\n                        ///LOGIC HERE\r\n                        var grupo = opcion.split(\"*\");\r\n                        if (grupo.length > 2) {\r\n                            console.warn(\"Artyom found a smart command with \" + (grupo.length - 1) + \" wildcards. Artyom only support 1 wildcard for each command. Sorry\");\r\n                            continue;\r\n                        }\r\n                        //START SMART COMMAND\r\n                        var before = grupo[0];\r\n                        var later = grupo[1];\r\n                        // Wildcard in the end\r\n                        if ((later == \"\") || (later == \" \")) {\r\n                            if ((voz.indexOf(before) != -1) || ((voz.toLowerCase()).indexOf(before.toLowerCase()) != -1)) {\r\n                                wildy = voz.replace(before, '');\r\n                                wildy = (wildy.toLowerCase()).replace(before.toLowerCase(), '');\r\n                                encontrado = parseInt(c.toString());\r\n                            }\r\n                        }\r\n                        else {\r\n                            if ((voz.indexOf(before) != -1) || ((voz.toLowerCase()).indexOf(before.toLowerCase()) != -1)) {\r\n                                if ((voz.indexOf(later) != -1) || ((voz.toLowerCase()).indexOf(later.toLowerCase()) != -1)) {\r\n                                    wildy = voz.replace(before, '').replace(later, '');\r\n                                    wildy = (wildy.toLowerCase()).replace(before.toLowerCase(), '').replace(later.toLowerCase(), '');\r\n                                    wildy = (wildy.toLowerCase()).replace(later.toLowerCase(), '');\r\n                                    encontrado = parseInt(c.toString());\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        console.warn(\"Founded command marked as SMART but have no wildcard in the indexes, remove the SMART for prevent extensive memory consuming or add the wildcard *\");\r\n                    }\r\n                }\r\n                if ((encontrado >= 0)) {\r\n                    encontrado = parseInt(c.toString());\r\n                    break;\r\n                }\r\n            }\r\n            if (encontrado >= 0) {\r\n                _this.triggerEvent(_this.ArtyomGlobalEvents.COMMAND_MATCHED);\r\n                var response = {\r\n                    index: encontrado,\r\n                    instruction: instruction,\r\n                    wildcard: {\r\n                        item: wildy,\r\n                        full: voz\r\n                    }\r\n                };\r\n                return response;\r\n            }\r\n        } //End @3\r\n        /** @1\r\n         * Search for IDENTICAL matches in the commands if nothing matches\r\n         * start with a index match in commands\r\n         */\r\n        for (var i = 0; i < _this.ArtyomCommands.length; i++) {\r\n            var instruction = _this.ArtyomCommands[i];\r\n            var opciones = instruction.indexes;\r\n            var encontrado = -1;\r\n            /**\r\n             * Execution of match with identical commands\r\n             */\r\n            for (var c = 0; c < opciones.length; c++) {\r\n                var opcion = opciones[c];\r\n                if (instruction.smart) {\r\n                    continue; //Jump wildcard commands\r\n                }\r\n                if ((voz === opcion)) {\r\n                    _this.debug(\">> MATCHED FULL EXACT OPTION \" + opcion + \" AGAINST \" + voz + \" WITH INDEX \" + c + \" IN COMMAND \", \"info\");\r\n                    encontrado = parseInt(c.toString());\r\n                    break;\r\n                }\r\n                else if ((voz.toLowerCase() === opcion.toLowerCase())) {\r\n                    _this.debug(\">> MATCHED OPTION CHANGING ALL TO LOWERCASE \" + opcion + \" AGAINST \" + voz + \" WITH INDEX \" + c + \" IN COMMAND \", \"info\");\r\n                    encontrado = parseInt(c.toString());\r\n                    break;\r\n                }\r\n            }\r\n            if (encontrado >= 0) {\r\n                _this.triggerEvent(_this.ArtyomGlobalEvents.COMMAND_MATCHED);\r\n                var response = {\r\n                    index: encontrado,\r\n                    instruction: instruction\r\n                };\r\n                return response;\r\n            }\r\n        } //End @1\r\n        /**\r\n         * Step 3 Commands recognition.\r\n         * If the command is not smart, and any of the commands match exactly then try to find\r\n         * a command in all the quote.\r\n         */\r\n        for (var i = 0; i < _this.ArtyomCommands.length; i++) {\r\n            var instruction = _this.ArtyomCommands[i];\r\n            var opciones = instruction.indexes;\r\n            var encontrado = -1;\r\n            /**\r\n             * Execution of match with index\r\n             */\r\n            for (var c = 0; c < opciones.length; c++) {\r\n                if (instruction.smart) {\r\n                    continue; //Jump wildcard commands\r\n                }\r\n                var opcion = opciones[c];\r\n                if ((voz.indexOf(opcion) >= 0)) {\r\n                    _this.debug(\">> MATCHED INDEX EXACT OPTION \" + opcion + \" AGAINST \" + voz + \" WITH INDEX \" + c + \" IN COMMAND \", \"info\");\r\n                    encontrado = parseInt(c.toString());\r\n                    break;\r\n                }\r\n                else if (((voz.toLowerCase()).indexOf(opcion.toLowerCase()) >= 0)) {\r\n                    _this.debug(\">> MATCHED INDEX OPTION CHANGING ALL TO LOWERCASE \" + opcion + \" AGAINST \" + voz + \" WITH INDEX \" + c + \" IN COMMAND \", \"info\");\r\n                    encontrado = parseInt(c.toString());\r\n                    break;\r\n                }\r\n            }\r\n            if (encontrado >= 0) {\r\n                _this.triggerEvent(_this.ArtyomGlobalEvents.COMMAND_MATCHED);\r\n                var response = {\r\n                    index: encontrado,\r\n                    instruction: instruction\r\n                };\r\n                return response;\r\n            }\r\n        } //End Step 3\r\n        /**\r\n         * If the soundex options is enabled, proceed to process the commands in case that any of the previous\r\n         * ways of processing (exact, lowercase and command in quote) didn't match anything.\r\n         * Based on the soundex algorithm match a command if the spoken text is similar to any of the artyom commands.\r\n         * Example :\r\n         * If you have a command with \"Open Wallmart\" and \"Open Willmar\" is recognized, the open wallmart command will be triggered.\r\n         * soundex(\"Open Wallmart\") == soundex(\"Open Willmar\") <= true\r\n         *\r\n         */\r\n        if (_this.ArtyomProperties.soundex) {\r\n            for (var i = 0; i < _this.ArtyomCommands.length; i++) {\r\n                var instruction = _this.ArtyomCommands[i];\r\n                var opciones = instruction.indexes;\r\n                var encontrado = -1;\r\n                for (var c = 0; c < opciones.length; c++) {\r\n                    var opcion = opciones[c];\r\n                    if (instruction.smart) {\r\n                        continue; //Jump wildcard commands\r\n                    }\r\n                    if (_this.soundex(voz) == _this.soundex(opcion)) {\r\n                        _this.debug(\">> Matched Soundex command '\" + opcion + \"' AGAINST '\" + voz + \"' with index \" + c, \"info\");\r\n                        encontrado = parseInt(c.toString());\r\n                        _this.triggerEvent(_this.ArtyomGlobalEvents.COMMAND_MATCHED);\r\n                        var response = {\r\n                            index: encontrado,\r\n                            instruction: instruction\r\n                        };\r\n                        return response;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        _this.debug(\"Event reached : \" + _this.ArtyomGlobalEvents.NOT_COMMAND_MATCHED);\r\n        _this.triggerEvent(_this.ArtyomGlobalEvents.NOT_COMMAND_MATCHED);\r\n        return;\r\n    };\r\n    /**\r\n     * Force artyom to stop listen even if is in continuos mode.\r\n     *\r\n     * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/fatality\r\n     * @returns {Boolean}\r\n     */\r\n    Artyom.prototype.fatality = function () {\r\n        var _this = this;\r\n        //fatalityPromiseCallback\r\n        return new Promise(function (resolve, reject) {\r\n            // Expose the fatality promise callback to the helpers object of Artyom.\r\n            // The promise isn't resolved here itself but in the onend callback of\r\n            // the speechRecognition instance of artyom\r\n            _this.ArtyomProperties.helpers.fatalityPromiseCallback = resolve;\r\n            try {\r\n                // If config is continuous mode, deactivate anyway.\r\n                _this.ArtyomFlags.restartRecognition = false;\r\n                _this.ArtyomWebkitSpeechRecognition.stop();\r\n            }\r\n            catch (e) {\r\n                reject(e);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Returns an array with all the available commands for artyom.\r\n     *\r\n     * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/getavailablecommands\r\n     * @readonly\r\n     * @returns {Array}\r\n     */\r\n    Artyom.prototype.getAvailableCommands = function () {\r\n        return this.ArtyomCommands;\r\n    };\r\n    /**\r\n     * Artyom can return inmediately the voices available in your browser.\r\n     *\r\n     * @readonly\r\n     * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/getvoices\r\n     * @returns {Array}\r\n     */\r\n    Artyom.prototype.getVoices = function () {\r\n        return window.speechSynthesis.getVoices();\r\n    };\r\n    /**\r\n     * Verify if the browser supports speechSynthesis.\r\n     *\r\n     * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/speechsupported\r\n     * @returns {Boolean}\r\n     */\r\n    Artyom.prototype.speechSupported = function () {\r\n        return 'speechSynthesis' in window;\r\n    };\r\n    /**\r\n     * Verify if the browser supports webkitSpeechRecognition.\r\n     *\r\n     * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/recognizingsupported\r\n     * @returns {Boolean}\r\n     */\r\n    Artyom.prototype.recognizingSupported = function () {\r\n        return 'webkitSpeechRecognition' in window;\r\n    };\r\n    /**\r\n     * Stops the actual and pendings messages that artyom have to say.\r\n     *\r\n     * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/shutup\r\n     * @returns {undefined}\r\n     */\r\n    Artyom.prototype.shutUp = function () {\r\n        if ('speechSynthesis' in window) {\r\n            do {\r\n                window.speechSynthesis.cancel();\r\n            } while (window.speechSynthesis.pending === true);\r\n        }\r\n        this.ArtyomProperties.speaking = false;\r\n        this.clearGarbageCollection();\r\n    };\r\n    /**\r\n     * Returns an object with the actual properties of artyom.\r\n     *\r\n     * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/getproperties\r\n     * @returns {object}\r\n     */\r\n    Artyom.prototype.getProperties = function () {\r\n        return this.ArtyomProperties;\r\n    };\r\n    /**\r\n     * Returns the code language of artyom according to initialize function.\r\n     * if initialize not used returns english GB.\r\n     *\r\n     * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/getlanguage\r\n     * @returns {String}\r\n     */\r\n    Artyom.prototype.getLanguage = function () {\r\n        return this.ArtyomProperties.lang;\r\n    };\r\n    /**\r\n     * Retrieves the used version of Artyom.js\r\n     *\r\n     * @returns {String}\r\n     */\r\n    Artyom.prototype.getVersion = function () {\r\n        return '1.0.6';\r\n    };\r\n    /**\r\n     * Artyom awaits for orders when this function\r\n     * is executed.\r\n     *\r\n     * If artyom gets a first parameter the instance will be stopped.\r\n     *\r\n     * @private\r\n     * @returns {undefined}\r\n     */\r\n    Artyom.prototype.hey = function (resolve, reject) {\r\n        var start_timestamp;\r\n        var artyom_is_allowed;\r\n        var _this = this;\r\n        /**\r\n         * On mobile devices the recognized text is always thrown twice.\r\n         * By setting the following configuration, fixes the issue\r\n         */\r\n        if (this.Device.isMobile) {\r\n            this.ArtyomWebkitSpeechRecognition.continuous = false;\r\n            this.ArtyomWebkitSpeechRecognition.interimResults = false;\r\n            this.ArtyomWebkitSpeechRecognition.maxAlternatives = 1;\r\n        }\r\n        else {\r\n            this.ArtyomWebkitSpeechRecognition.continuous = true;\r\n            this.ArtyomWebkitSpeechRecognition.interimResults = true;\r\n        }\r\n        this.ArtyomWebkitSpeechRecognition.lang = this.ArtyomProperties.lang;\r\n        this.ArtyomWebkitSpeechRecognition.onstart = function () {\r\n            _this.debug(\"Event reached : \" + _this.ArtyomGlobalEvents.COMMAND_RECOGNITION_START);\r\n            _this.triggerEvent(_this.ArtyomGlobalEvents.COMMAND_RECOGNITION_START);\r\n            _this.ArtyomProperties.recognizing = true;\r\n            artyom_is_allowed = true;\r\n            resolve();\r\n        };\r\n        /**\r\n         * Handle all artyom posible exceptions\r\n         *\r\n         * @param {type} event\r\n         * @returns {undefined}\r\n         */\r\n        this.ArtyomWebkitSpeechRecognition.onerror = function (event) {\r\n            // Reject promise on initialization\r\n            reject(event.error);\r\n            // Dispath error globally (artyom.when)\r\n            _this.triggerEvent(_this.ArtyomGlobalEvents.ERROR, {\r\n                code: event.error\r\n            });\r\n            if (event.error == 'audio-capture') {\r\n                artyom_is_allowed = false;\r\n            }\r\n            if (event.error == 'not-allowed') {\r\n                artyom_is_allowed = false;\r\n                if (event.timeStamp - start_timestamp < 100) {\r\n                    _this.triggerEvent(_this.ArtyomGlobalEvents.ERROR, {\r\n                        code: \"info-blocked\",\r\n                        message: \"Artyom needs the permision of the microphone, is blocked.\"\r\n                    });\r\n                }\r\n                else {\r\n                    _this.triggerEvent(_this.ArtyomGlobalEvents.ERROR, {\r\n                        code: \"info-denied\",\r\n                        message: \"Artyom needs the permision of the microphone, is denied\"\r\n                    });\r\n                }\r\n            }\r\n        };\r\n        /**\r\n         * Check if continuous mode is active and restart the recognition.\r\n         * Throw events too.\r\n         *\r\n         * @returns {undefined}\r\n         */\r\n        _this.ArtyomWebkitSpeechRecognition.onend = function () {\r\n            if (_this.ArtyomFlags.restartRecognition === true) {\r\n                if (artyom_is_allowed === true) {\r\n                    _this.ArtyomWebkitSpeechRecognition.start();\r\n                    _this.debug(\"Continuous mode enabled, restarting\", \"info\");\r\n                }\r\n                else {\r\n                    console.error(\"Verify the microphone and check for the table of errors in sdkcarlos.github.io/sites/artyom.html to solve your problem. If you want to give your user a message when an error appears add an artyom listener\");\r\n                }\r\n                _this.triggerEvent(_this.ArtyomGlobalEvents.COMMAND_RECOGNITION_END, {\r\n                    code: \"continuous_mode_enabled\",\r\n                    message: \"OnEnd event reached with continuous mode\"\r\n                });\r\n            }\r\n            else {\r\n                // If the fatality promise callback was set, invoke it\r\n                if (_this.ArtyomProperties.helpers.fatalityPromiseCallback) {\r\n                    // As the speech recognition doesn't finish really, wait 500ms\r\n                    // to trigger the real fatality callback\r\n                    setTimeout(function () {\r\n                        _this.ArtyomProperties.helpers.fatalityPromiseCallback();\r\n                    }, 500);\r\n                    _this.triggerEvent(_this.ArtyomGlobalEvents.COMMAND_RECOGNITION_END, {\r\n                        code: \"continuous_mode_disabled\",\r\n                        message: \"OnEnd event reached without continuous mode\"\r\n                    });\r\n                }\r\n            }\r\n            _this.ArtyomProperties.recognizing = false;\r\n        };\r\n        /**\r\n         * Declare the processor dinamycally according to the mode of artyom\r\n         * to increase the performance.\r\n         *\r\n         * @type {Function}\r\n         * @return\r\n         */\r\n        var onResultProcessor;\r\n        // Process the recognition in normal mode\r\n        if (_this.ArtyomProperties.mode == \"normal\") {\r\n            onResultProcessor = function (event) {\r\n                if (!_this.ArtyomCommands.length) {\r\n                    _this.debug(\"No commands to process in normal mode.\");\r\n                    return;\r\n                }\r\n                var cantidadResultados = event.results.length;\r\n                _this.triggerEvent(_this.ArtyomGlobalEvents.TEXT_RECOGNIZED);\r\n                for (var i = event.resultIndex; i < cantidadResultados; ++i) {\r\n                    var identificated = event.results[i][0].transcript;\r\n                    if (event.results[i].isFinal) {\r\n                        var comando = _this.execute(identificated.trim());\r\n                        // Redirect the output of the text if necessary\r\n                        if (typeof (_this.ArtyomProperties.helpers.redirectRecognizedTextOutput) === \"function\") {\r\n                            _this.ArtyomProperties.helpers.redirectRecognizedTextOutput(identificated, true);\r\n                        }\r\n                        if ((comando) && (_this.ArtyomProperties.recognizing == true)) {\r\n                            _this.debug(\"<< Executing Matching Recognition in normal mode >>\", \"info\");\r\n                            _this.ArtyomWebkitSpeechRecognition.stop();\r\n                            _this.ArtyomProperties.recognizing = false;\r\n                            // Execute the command if smart\r\n                            if (comando.wildcard) {\r\n                                comando.instruction.action(comando.index, comando.wildcard.item, comando.wildcard.full);\r\n                                // Execute a normal command\r\n                            }\r\n                            else {\r\n                                comando.instruction.action(comando.index);\r\n                            }\r\n                            break;\r\n                        }\r\n                    }\r\n                    else {\r\n                        // Redirect output when necesary\r\n                        if (typeof (_this.ArtyomProperties.helpers.redirectRecognizedTextOutput) === \"function\") {\r\n                            _this.ArtyomProperties.helpers.redirectRecognizedTextOutput(identificated, false);\r\n                        }\r\n                        if (typeof (_this.ArtyomProperties.executionKeyword) === \"string\") {\r\n                            if (identificated.indexOf(_this.ArtyomProperties.executionKeyword) != -1) {\r\n                                var comando = _this.execute(identificated.replace(_this.ArtyomProperties.executionKeyword, '').trim());\r\n                                if ((comando) && (_this.ArtyomProperties.recognizing == true)) {\r\n                                    _this.debug(\"<< Executing command ordered by ExecutionKeyword >>\", 'info');\r\n                                    _this.ArtyomWebkitSpeechRecognition.stop();\r\n                                    _this.ArtyomProperties.recognizing = false;\r\n                                    //Executing Command Action\r\n                                    if (comando.wildcard) {\r\n                                        comando.instruction.action(comando.index, comando.wildcard.item, comando.wildcard.full);\r\n                                    }\r\n                                    else {\r\n                                        comando.instruction.action(comando.index);\r\n                                    }\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                        _this.debug(\"Normal mode : \" + identificated);\r\n                    }\r\n                }\r\n            };\r\n        }\r\n        // Process the recognition in quick mode\r\n        if (_this.ArtyomProperties.mode == \"quick\") {\r\n            onResultProcessor = function (event) {\r\n                if (!_this.ArtyomCommands.length) {\r\n                    _this.debug(\"No commands to process.\");\r\n                    return;\r\n                }\r\n                var cantidadResultados = event.results.length;\r\n                _this.triggerEvent(_this.ArtyomGlobalEvents.TEXT_RECOGNIZED);\r\n                for (var i = event.resultIndex; i < cantidadResultados; ++i) {\r\n                    var identificated = event.results[i][0].transcript;\r\n                    if (!event.results[i].isFinal) {\r\n                        var comando = _this.execute(identificated.trim());\r\n                        //Redirect output when necesary\r\n                        if (typeof (_this.ArtyomProperties.helpers.redirectRecognizedTextOutput) === \"function\") {\r\n                            _this.ArtyomProperties.helpers.redirectRecognizedTextOutput(identificated, true);\r\n                        }\r\n                        if ((comando) && (_this.ArtyomProperties.recognizing == true)) {\r\n                            _this.debug(\"<< Executing Matching Recognition in quick mode >>\", \"info\");\r\n                            _this.ArtyomWebkitSpeechRecognition.stop();\r\n                            _this.ArtyomProperties.recognizing = false;\r\n                            //Executing Command Action\r\n                            if (comando.wildcard) {\r\n                                comando.instruction.action(comando.index, comando.wildcard.item);\r\n                            }\r\n                            else {\r\n                                comando.instruction.action(comando.index);\r\n                            }\r\n                            break;\r\n                        }\r\n                    }\r\n                    else {\r\n                        var comando = _this.execute(identificated.trim());\r\n                        //Redirect output when necesary\r\n                        if (typeof (_this.ArtyomProperties.helpers.redirectRecognizedTextOutput) === \"function\") {\r\n                            _this.ArtyomProperties.helpers.redirectRecognizedTextOutput(identificated, false);\r\n                        }\r\n                        if ((comando) && (_this.ArtyomProperties.recognizing == true)) {\r\n                            _this.debug(\"<< Executing Matching Recognition in quick mode >>\", \"info\");\r\n                            _this.ArtyomWebkitSpeechRecognition.stop();\r\n                            _this.ArtyomProperties.recognizing = false;\r\n                            //Executing Command Action\r\n                            if (comando.wildcard) {\r\n                                comando.instruction.action(comando.index, comando.wildcard.item);\r\n                            }\r\n                            else {\r\n                                comando.instruction.action(comando.index);\r\n                            }\r\n                            break;\r\n                        }\r\n                    }\r\n                    _this.debug(\"Quick mode : \" + identificated);\r\n                }\r\n            };\r\n        }\r\n        // Process the recognition in remote mode\r\n        if (_this.ArtyomProperties.mode == \"remote\") {\r\n            onResultProcessor = function (event) {\r\n                var cantidadResultados = event.results.length;\r\n                _this.triggerEvent(_this.ArtyomGlobalEvents.TEXT_RECOGNIZED);\r\n                if (typeof (_this.ArtyomProperties.helpers.remoteProcessorHandler) !== \"function\") {\r\n                    return _this.debug(\"The remoteProcessorService is undefined.\", \"warn\");\r\n                }\r\n                for (var i = event.resultIndex; i < cantidadResultados; ++i) {\r\n                    var identificated = event.results[i][0].transcript;\r\n                    _this.ArtyomProperties.helpers.remoteProcessorHandler({\r\n                        text: identificated,\r\n                        isFinal: event.results[i].isFinal\r\n                    });\r\n                }\r\n            };\r\n        }\r\n        /**\r\n         * Process the recognition event with the previously\r\n         * declared processor function.\r\n         *\r\n         * @param {type} event\r\n         * @returns {undefined}\r\n         */\r\n        _this.ArtyomWebkitSpeechRecognition.onresult = function (event) {\r\n            if (_this.ArtyomProperties.obeying) {\r\n                onResultProcessor(event);\r\n            }\r\n            else {\r\n                // Handle obeyKeyword if exists and artyom is not obeying\r\n                if (!_this.ArtyomProperties.obeyKeyword) {\r\n                    return;\r\n                }\r\n                var temporal = \"\";\r\n                var interim = \"\";\r\n                for (var i = 0; i < event.results.length; ++i) {\r\n                    if (event.results[i].isFinal) {\r\n                        temporal += event.results[i][0].transcript;\r\n                    }\r\n                    else {\r\n                        interim += event.results[i][0].transcript;\r\n                    }\r\n                }\r\n                _this.debug(\"Artyom is not obeying\", \"warn\");\r\n                // If the obeyKeyword is found in the recognized text\r\n                // enable command recognition again\r\n                if (((interim).indexOf(_this.ArtyomProperties.obeyKeyword) > -1) || (temporal).indexOf(_this.ArtyomProperties.obeyKeyword) > -1) {\r\n                    _this.ArtyomProperties.obeying = true;\r\n                }\r\n            }\r\n        };\r\n        if (_this.ArtyomProperties.recognizing) {\r\n            _this.ArtyomWebkitSpeechRecognition.stop();\r\n            _this.debug(\"Event reached : \" + _this.ArtyomGlobalEvents.COMMAND_RECOGNITION_END);\r\n            _this.triggerEvent(_this.ArtyomGlobalEvents.COMMAND_RECOGNITION_END);\r\n        }\r\n        else {\r\n            try {\r\n                _this.ArtyomWebkitSpeechRecognition.start();\r\n            }\r\n            catch (e) {\r\n                _this.triggerEvent(_this.ArtyomGlobalEvents.ERROR, {\r\n                    code: \"recognition_overlap\",\r\n                    message: \"A webkitSpeechRecognition instance has been started while there's already running. Is recommendable to restart the Browser\"\r\n                });\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Set up artyom for the application.\r\n     *\r\n     * This function will set the default language used by artyom\r\n     * or notice the user if artyom is not supported in the actual\r\n     * browser\r\n     * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/initialize\r\n     * @param {Object} config\r\n     * @returns {Boolean}\r\n     */\r\n    Artyom.prototype.initialize = function (config) {\r\n        var _this = this;\r\n        if (typeof (config) !== \"object\") {\r\n            return Promise.reject(\"You must give the configuration for start artyom properly.\");\r\n        }\r\n        if (config.hasOwnProperty(\"lang\")) {\r\n            _this.ArtyomVoice = _this.getVoice(config.lang);\r\n            _this.ArtyomProperties.lang = config.lang;\r\n        }\r\n        if (config.hasOwnProperty(\"continuous\")) {\r\n            if (config.continuous) {\r\n                this.ArtyomProperties.continuous = true;\r\n                this.ArtyomFlags.restartRecognition = true;\r\n            }\r\n            else {\r\n                this.ArtyomProperties.continuous = false;\r\n                this.ArtyomFlags.restartRecognition = false;\r\n            }\r\n        }\r\n        if (config.hasOwnProperty(\"speed\")) {\r\n            this.ArtyomProperties.speed = config.speed;\r\n        }\r\n        if (config.hasOwnProperty(\"soundex\")) {\r\n            this.ArtyomProperties.soundex = config.soundex;\r\n        }\r\n        if (config.hasOwnProperty(\"executionKeyword\")) {\r\n            this.ArtyomProperties.executionKeyword = config.executionKeyword;\r\n        }\r\n        if (config.hasOwnProperty(\"obeyKeyword\")) {\r\n            this.ArtyomProperties.obeyKeyword = config.obeyKeyword;\r\n        }\r\n        if (config.hasOwnProperty(\"volume\")) {\r\n            this.ArtyomProperties.volume = config.volume;\r\n        }\r\n        if (config.hasOwnProperty(\"listen\")) {\r\n            this.ArtyomProperties.listen = config.listen;\r\n        }\r\n        if (config.hasOwnProperty(\"name\")) {\r\n            this.ArtyomProperties.name = config.name;\r\n        }\r\n        if (config.hasOwnProperty(\"debug\")) {\r\n            this.ArtyomProperties.debug = config.debug;\r\n        }\r\n        else {\r\n            console.warn(\"The initialization doesn't provide how the debug mode should be handled. Is recommendable to set this value either to true or false.\");\r\n        }\r\n        if (config.mode) {\r\n            this.ArtyomProperties.mode = config.mode;\r\n        }\r\n        if (this.ArtyomProperties.listen === true) {\r\n            return new Promise(function (resolve, reject) {\r\n                _this.hey(resolve, reject);\r\n            });\r\n        }\r\n        return Promise.resolve(true);\r\n    };\r\n    /**\r\n     * Add commands like an artisan. If you use artyom for simple tasks\r\n     * then probably you don't like to write a lot to achieve it.\r\n     *\r\n     * Use the artisan syntax to write less, but with the same accuracy.\r\n     *\r\n     * @disclaimer Not a promise-based implementation, just syntax.\r\n     * @returns {Boolean}\r\n     */\r\n    Artyom.prototype.on = function (indexes, smart) {\r\n        var _this = this;\r\n        return {\r\n            then: function (action) {\r\n                var command = {\r\n                    indexes: indexes,\r\n                    action: action\r\n                };\r\n                if (smart) {\r\n                    command.smart = true;\r\n                }\r\n                _this.addCommands(command);\r\n            }\r\n        };\r\n    };\r\n    /**\r\n     * Generates an artyom event with the designed name\r\n     *\r\n     * @param {type} name\r\n     * @returns {undefined}\r\n     */\r\n    Artyom.prototype.triggerEvent = function (name, param) {\r\n        var event = new CustomEvent(name, {\r\n            'detail': param\r\n        });\r\n        document.dispatchEvent(event);\r\n        return event;\r\n    };\r\n    /**\r\n     * Repeats the last sentence that artyom said.\r\n     * Useful in noisy environments.\r\n     *\r\n     * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/repeatlastsay\r\n     * @param {Boolean} returnObject If set to true, an object with the text and the timestamp when was executed will be returned.\r\n     * @returns {Object}\r\n     */\r\n    Artyom.prototype.repeatLastSay = function (returnObject) {\r\n        var last = this.ArtyomProperties.helpers.lastSay;\r\n        if (returnObject) {\r\n            return last;\r\n        }\r\n        else {\r\n            if (last != null) {\r\n                this.say(last.text);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Create a listener when an artyom action is called.\r\n     *\r\n     * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/when\r\n     * @param {type} event\r\n     * @param {type} action\r\n     * @returns {undefined}\r\n     */\r\n    Artyom.prototype.when = function (event, action) {\r\n        return document.addEventListener(event, function (e) {\r\n            action(e[\"detail\"]);\r\n        }, false);\r\n    };\r\n    /**\r\n     * Process the recognized text if artyom is active in remote mode.\r\n     *\r\n     * @returns {Boolean}\r\n     */\r\n    Artyom.prototype.remoteProcessorService = function (action) {\r\n        this.ArtyomProperties.helpers.remoteProcessorHandler = action;\r\n        return true;\r\n    };\r\n    /**\r\n     * Verify if there's a voice available for a language using its language code identifier.\r\n     *\r\n     * @return {Boolean}\r\n     */\r\n    Artyom.prototype.voiceAvailable = function (languageCode) {\r\n        return typeof (this.getVoice(languageCode)) !== \"undefined\";\r\n    };\r\n    /**\r\n     * A boolean to check if artyom is obeying commands or not.\r\n     *\r\n     * @returns {Boolean}\r\n     */\r\n    Artyom.prototype.isObeying = function () {\r\n        return this.ArtyomProperties.obeying;\r\n    };\r\n    /**\r\n     * Allow artyom to obey commands again.\r\n     *\r\n     * @returns {Boolean}\r\n     */\r\n    Artyom.prototype.obey = function () {\r\n        return this.ArtyomProperties.obeying = true;\r\n    };\r\n    /**\r\n     * Pause the processing of commands. Artyom still listening in the background and it can be resumed after a couple of seconds.\r\n     *\r\n     * @returns {Boolean}\r\n     */\r\n    Artyom.prototype.dontObey = function () {\r\n        return this.ArtyomProperties.obeying = false;\r\n    };\r\n    /**\r\n     * This function returns a boolean according to the speechSynthesis status\r\n     * if artyom is speaking, will return true.\r\n     *\r\n     * Note: This is not a feature of speechSynthesis, therefore this value hangs on\r\n     * the fiability of the onStart and onEnd events of the speechSynthesis\r\n     *\r\n     * @since 0.9.3\r\n     * @summary Returns true if speechSynthesis is active\r\n     * @returns {Boolean}\r\n     */\r\n    Artyom.prototype.isSpeaking = function () {\r\n        return this.ArtyomProperties.speaking;\r\n    };\r\n    /**\r\n     * This function returns a boolean according to the SpeechRecognition status\r\n     * if artyom is listening, will return true.\r\n     *\r\n     * Note: This is not a feature of SpeechRecognition, therefore this value hangs on\r\n     * the fiability of the onStart and onEnd events of the SpeechRecognition\r\n     *\r\n     * @since 0.9.3\r\n     * @summary Returns true if SpeechRecognition is active\r\n     * @returns {Boolean}\r\n     */\r\n    Artyom.prototype.isRecognizing = function () {\r\n        return this.ArtyomProperties.recognizing;\r\n    };\r\n    /**\r\n     * This function will return the webkitSpeechRecognition object used by artyom\r\n     * retrieve it only to debug on it or get some values, do not make changes directly\r\n     *\r\n     * @readonly\r\n     * @since 0.9.2\r\n     * @summary Retrieve the native webkitSpeechRecognition object\r\n     * @returns {Object webkitSpeechRecognition}\r\n     */\r\n    Artyom.prototype.getNativeApi = function () {\r\n        return this.ArtyomWebkitSpeechRecognition;\r\n    };\r\n    /**\r\n     * Returns the SpeechSynthesisUtterance garbageobjects.\r\n     *\r\n     * @returns {Array}\r\n     */\r\n    Artyom.prototype.getGarbageCollection = function () {\r\n        return this.ArtyomGarbageCollection;\r\n    };\r\n    /**\r\n     *  Retrieve a single voice of the browser by it's language code.\r\n     *  It will return the first voice available for the language on every device.\r\n     *\r\n     * @param languageCode\r\n     */\r\n    Artyom.prototype.getVoice = function (languageCode) {\r\n        var voiceIdentifiersArray = this.ArtyomVoicesIdentifiers[languageCode];\r\n        if (!voiceIdentifiersArray) {\r\n            console.warn(\"The providen language \" + languageCode + \" isn't available, using English Great britain as default\");\r\n            voiceIdentifiersArray = this.ArtyomVoicesIdentifiers[\"en-GB\"];\r\n        }\r\n        var voice = undefined;\r\n        var voices = speechSynthesis.getVoices();\r\n        var voicesLength = voiceIdentifiersArray.length;\r\n        var _loop_1 = function (i) {\r\n            var foundVoice = voices.filter(function (voice) {\r\n                return ((voice.name == voiceIdentifiersArray[i]) || (voice.lang == voiceIdentifiersArray[i]));\r\n            })[0];\r\n            if (foundVoice) {\r\n                voice = foundVoice;\r\n                return \"break\";\r\n            }\r\n        };\r\n        for (var i = 0; i < voicesLength; i++) {\r\n            var state_1 = _loop_1(i);\r\n            if (state_1 === \"break\")\r\n                break;\r\n        }\r\n        return voice;\r\n    };\r\n    /**\r\n     * Artyom provide an easy way to create a\r\n     * dictation for your user.\r\n     *\r\n     * Just create an instance and start and stop when you want\r\n     *\r\n     * @returns Object | newDictation\r\n     */\r\n    Artyom.prototype.newDictation = function (settings) {\r\n        var _this = this;\r\n        if (!_this.recognizingSupported()) {\r\n            console.error(\"SpeechRecognition is not supported in this browser\");\r\n            return false;\r\n        }\r\n        var dictado = new window.webkitSpeechRecognition();\r\n        dictado.continuous = true;\r\n        dictado.interimResults = true;\r\n        dictado.lang = _this.ArtyomProperties.lang;\r\n        dictado.onresult = function (event) {\r\n            var temporal = \"\";\r\n            var interim = \"\";\r\n            for (var i = 0; i < event.results.length; ++i) {\r\n                if (event.results[i].isFinal) {\r\n                    temporal += event.results[i][0].transcript;\r\n                }\r\n                else {\r\n                    interim += event.results[i][0].transcript;\r\n                }\r\n            }\r\n            if (settings.onResult) {\r\n                settings.onResult(interim, temporal);\r\n            }\r\n        };\r\n        return new function () {\r\n            var dictation = dictado;\r\n            var flagStartCallback = true;\r\n            var flagRestart = false;\r\n            this.onError = null;\r\n            this.start = function () {\r\n                if (settings.continuous === true) {\r\n                    flagRestart = true;\r\n                }\r\n                dictation.onstart = function () {\r\n                    if (typeof (settings.onStart) === \"function\") {\r\n                        if (flagStartCallback === true) {\r\n                            settings.onStart();\r\n                        }\r\n                    }\r\n                };\r\n                dictation.onend = function () {\r\n                    if (flagRestart === true) {\r\n                        flagStartCallback = false;\r\n                        dictation.start();\r\n                    }\r\n                    else {\r\n                        flagStartCallback = true;\r\n                        if (typeof (settings.onEnd) === \"function\") {\r\n                            settings.onEnd();\r\n                        }\r\n                    }\r\n                };\r\n                dictation.start();\r\n            };\r\n            this.stop = function () {\r\n                flagRestart = false;\r\n                dictation.stop();\r\n            };\r\n            if (typeof (settings.onError) === \"function\") {\r\n                dictation.onerror = settings.onError;\r\n            }\r\n        };\r\n    };\r\n    /**\r\n     * A voice prompt will be executed.\r\n     *\r\n     * @param {type} config\r\n     * @returns {undefined}\r\n     */\r\n    Artyom.prototype.newPrompt = function (config) {\r\n        if (typeof (config) !== \"object\") {\r\n            console.error(\"Expected the prompt configuration.\");\r\n        }\r\n        var copyActualCommands = Object.assign([], this.ArtyomCommands);\r\n        var _this = this;\r\n        this.emptyCommands();\r\n        var promptCommand = {\r\n            description: \"Setting the artyom commands only for the prompt. The commands will be restored after the prompt finishes\",\r\n            indexes: config.options,\r\n            action: function (i, wildcard) {\r\n                _this.ArtyomCommands = copyActualCommands;\r\n                var toExe = config.onMatch(i, wildcard);\r\n                if (typeof (toExe) !== \"function\") {\r\n                    console.error(\"onMatch function expects a returning function to be executed\");\r\n                    return;\r\n                }\r\n                toExe();\r\n            }\r\n        };\r\n        if (config.smart) {\r\n            promptCommand.smart = true;\r\n        }\r\n        this.addCommands(promptCommand);\r\n        if (typeof (config.beforePrompt) !== \"undefined\") {\r\n            config.beforePrompt();\r\n        }\r\n        var callbacks = {\r\n            onStart: function () {\r\n                if (typeof (config.onStartPrompt) !== \"undefined\") {\r\n                    config.onStartPrompt();\r\n                }\r\n            },\r\n            onEnd: function () {\r\n                if (typeof (config.onEndPrompt) !== \"undefined\") {\r\n                    config.onEndPrompt();\r\n                }\r\n            }\r\n        };\r\n        this.say(config.question, callbacks);\r\n    };\r\n    /**\r\n     * Says a random quote and returns it's object\r\n     *\r\n     * @param {type} data\r\n     * @returns {object}\r\n     */\r\n    Artyom.prototype.sayRandom = function (data) {\r\n        if (data instanceof Array) {\r\n            var index = Math.floor(Math.random() * data.length);\r\n            this.say(data[index]);\r\n            return {\r\n                text: data[index],\r\n                index: index\r\n            };\r\n        }\r\n        else {\r\n            console.error(\"Random quotes must be in an array !\");\r\n            return null;\r\n        }\r\n    };\r\n    /**\r\n     * Shortcut method to enable the artyom debug on the fly.\r\n     *\r\n     * @returns {Array}\r\n     */\r\n    Artyom.prototype.setDebug = function (status) {\r\n        if (status) {\r\n            return this.ArtyomProperties.debug = true;\r\n        }\r\n        else {\r\n            return this.ArtyomProperties.debug = false;\r\n        }\r\n    };\r\n    /**\r\n     * Simulate a voice command via JS\r\n     *\r\n     * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/simulateinstruction\r\n     * @param {type} sentence\r\n     * @returns {undefined}\r\n     */\r\n    Artyom.prototype.simulateInstruction = function (sentence) {\r\n        var _this = this;\r\n        if ((!sentence) || (typeof (sentence) !== \"string\")) {\r\n            console.warn(\"Cannot execute a non string command\");\r\n            return false;\r\n        }\r\n        var foundCommand = _this.execute(sentence); //Command founded object\r\n        if (typeof (foundCommand) === \"object\") {\r\n            if (foundCommand.instruction) {\r\n                if (foundCommand.instruction.smart) {\r\n                    _this.debug('Smart command matches with simulation, executing', \"info\");\r\n                    foundCommand.instruction.action(foundCommand.index, foundCommand.wildcard.item, foundCommand.wildcard.full);\r\n                }\r\n                else {\r\n                    _this.debug('Command matches with simulation, executing', \"info\");\r\n                    foundCommand.instruction.action(foundCommand.index); //Execute Normal command\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        else {\r\n            console.warn(\"No command founded trying with \" + sentence);\r\n            return false;\r\n        }\r\n    };\r\n    /**\r\n     * Javascript implementation of the soundex algorithm.\r\n     * @see https://gist.github.com/shawndumas/1262659\r\n     * @returns {String}\r\n     */\r\n    Artyom.prototype.soundex = function (s) {\r\n        var a = s.toLowerCase().split('');\r\n        var f = a.shift();\r\n        var r = '';\r\n        var codes = { a: \"\", e: \"\", i: \"\", o: \"\", u: \"\", b: 1, f: 1, p: 1, v: 1, c: 2, g: 2, j: 2, k: 2, q: 2, s: 2, x: 2, z: 2, d: 3, t: 3, l: 4, m: 5, n: 5, r: 6 };\r\n        r = f + a\r\n            .map(function (v, i, a) {\r\n            return codes[v];\r\n        })\r\n            .filter(function (v, i, a) {\r\n            return ((i === 0) ? v !== codes[f] : v !== a[i - 1]);\r\n        })\r\n            .join('');\r\n        return (r + '000').slice(0, 4).toUpperCase();\r\n    };\r\n    /**\r\n     * Splits a string into an array of strings with a limited size (chunk_length).\r\n     *\r\n     * @param {String} input text to split into chunks\r\n     * @param {Integer} chunk_length limit of characters in every chunk\r\n     */\r\n    Artyom.prototype.splitStringByChunks = function (input, chunk_length) {\r\n        input = input || \"\";\r\n        chunk_length = chunk_length || 100;\r\n        var curr = chunk_length;\r\n        var prev = 0;\r\n        var output = [];\r\n        while (input[curr]) {\r\n            if (input[curr++] == ' ') {\r\n                output.push(input.substring(prev, curr));\r\n                prev = curr;\r\n                curr += chunk_length;\r\n            }\r\n        }\r\n        output.push(input.substr(prev));\r\n        return output;\r\n    };\r\n    /**\r\n     * Allows to retrieve the recognized spoken text of artyom\r\n     * and do something with it everytime something is recognized\r\n     *\r\n     * @param {String} action\r\n     * @returns {Boolean}\r\n     */\r\n    Artyom.prototype.redirectRecognizedTextOutput = function (action) {\r\n        if (typeof (action) != \"function\") {\r\n            console.warn(\"Expected function to handle the recognized text ...\");\r\n            return false;\r\n        }\r\n        this.ArtyomProperties.helpers.redirectRecognizedTextOutput = action;\r\n        return true;\r\n    };\r\n    /**\r\n     * Restarts artyom with the initial configuration.\r\n     *\r\n     * @param configuration\r\n     */\r\n    Artyom.prototype.restart = function () {\r\n        var _this = this;\r\n        var _copyInit = _this.ArtyomProperties;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.fatality().then(function () {\r\n                _this.initialize(_copyInit).then(resolve, reject);\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Talks a text according to the given parameters.\r\n     *\r\n     * @private This function is only to be used internally.\r\n     * @param {String} text Text to be spoken\r\n     * @param {Int} actualChunk Number of chunk of the\r\n     * @param {Int} totalChunks\r\n     * @returns {undefined}\r\n     */\r\n    Artyom.prototype.talk = function (text, actualChunk, totalChunks, callbacks) {\r\n        var _this = this;\r\n        var msg = new SpeechSynthesisUtterance();\r\n        msg.text = text;\r\n        msg.volume = this.ArtyomProperties.volume;\r\n        msg.rate = this.ArtyomProperties.speed;\r\n        // Select the voice according to the selected\r\n        var availableVoice = _this.getVoice(_this.ArtyomProperties.lang);\r\n        if (callbacks) {\r\n            // If the language to speak has been forced, use it\r\n            if (callbacks.hasOwnProperty(\"lang\")) {\r\n                availableVoice = _this.getVoice(callbacks.lang);\r\n            }\r\n        }\r\n        // If is a mobile device, provide only the language code in the lang property i.e \"es_ES\"\r\n        if (this.Device.isMobile) {\r\n            // Try to set the voice only if exists, otherwise don't use anything to use the native voice\r\n            if (availableVoice) {\r\n                msg.lang = availableVoice.lang;\r\n            }\r\n            // If browser provide the entire object\r\n        }\r\n        else {\r\n            msg.voice = availableVoice;\r\n        }\r\n        // If is first text chunk (onStart)\r\n        if (actualChunk == 1) {\r\n            msg.addEventListener('start', function () {\r\n                // Set artyom is talking\r\n                _this.ArtyomProperties.speaking = true;\r\n                // Trigger the onSpeechSynthesisStart event\r\n                _this.debug(\"Event reached : \" + _this.ArtyomGlobalEvents.SPEECH_SYNTHESIS_START);\r\n                _this.triggerEvent(_this.ArtyomGlobalEvents.SPEECH_SYNTHESIS_START);\r\n                // Trigger the onStart callback if exists\r\n                if (callbacks) {\r\n                    if (typeof (callbacks.onStart) == \"function\") {\r\n                        callbacks.onStart.call(msg);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        // If is final text chunk (onEnd)\r\n        if ((actualChunk) >= totalChunks) {\r\n            msg.addEventListener('end', function () {\r\n                // Set artyom is talking\r\n                _this.ArtyomProperties.speaking = false;\r\n                // Trigger the onSpeechSynthesisEnd event\r\n                _this.debug(\"Event reached : \" + _this.ArtyomGlobalEvents.SPEECH_SYNTHESIS_END);\r\n                _this.triggerEvent(_this.ArtyomGlobalEvents.SPEECH_SYNTHESIS_END);\r\n                // Trigger the onEnd callback if exists.\r\n                if (callbacks) {\r\n                    if (typeof (callbacks.onEnd) == \"function\") {\r\n                        callbacks.onEnd.call(msg);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        // Notice how many chunks were processed for the given text.\r\n        this.debug((actualChunk) + \" text chunk processed succesfully out of \" + totalChunks);\r\n        // Important : Save the SpeechSynthesisUtterance object in memory, otherwise it will get lost\r\n        this.ArtyomGarbageCollection.push(msg);\r\n        window.speechSynthesis.speak(msg);\r\n    };\r\n    /**\r\n     * Process the given text into chunks and execute the private function talk\r\n     *\r\n     * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/say\r\n     * @param {String} message Text to be spoken\r\n     * @param {Object} callbacks\r\n     * @returns {undefined}\r\n     */\r\n    Artyom.prototype.say = function (message, callbacks) {\r\n        var artyom_say_max_chunk_length = 115;\r\n        var _this = this;\r\n        var definitive = [];\r\n        if (this.speechSupported()) {\r\n            if (typeof (message) != 'string') {\r\n                return console.warn(\"Artyom expects a string to speak \" + typeof message + \" given\");\r\n            }\r\n            if (!message.length) {\r\n                return console.warn(\"Cannot speak empty string\");\r\n            }\r\n            // If the providen text is long, proceed to split it\r\n            if (message.length > artyom_say_max_chunk_length) {\r\n                // Split the given text by pause reading characters [\",\",\":\",\";\",\". \"] to provide a natural reading feeling.\r\n                var naturalReading = message.split(/,|:|\\. |;/);\r\n                naturalReading.forEach(function (chunk, index) {\r\n                    // If the sentence is too long and could block the API, split it to prevent any errors.\r\n                    if (chunk.length > artyom_say_max_chunk_length) {\r\n                        // Process the providen string into strings (withing an array) of maximum aprox. 115 characters to prevent any error with the API.\r\n                        var temp_processed = _this.splitStringByChunks(chunk, artyom_say_max_chunk_length);\r\n                        // Add items of the processed sentence into the definitive chunk.\r\n                        definitive.push.apply(definitive, temp_processed);\r\n                    }\r\n                    else {\r\n                        // Otherwise just add the sentence to being spoken.\r\n                        definitive.push(chunk);\r\n                    }\r\n                });\r\n            }\r\n            else {\r\n                definitive.push(message);\r\n            }\r\n            // Clean any empty item in array\r\n            definitive = definitive.filter(function (e) { return e; });\r\n            // Finally proceed to talk the chunks and assign the callbacks.\r\n            definitive.forEach(function (chunk, index) {\r\n                var numberOfChunk = (index + 1);\r\n                if (chunk) {\r\n                    _this.talk(chunk, numberOfChunk, definitive.length, callbacks);\r\n                }\r\n            });\r\n            // Save the spoken text into the lastSay object of artyom\r\n            _this.ArtyomProperties.helpers.lastSay = {\r\n                text: message,\r\n                date: new Date()\r\n            };\r\n        }\r\n    };\r\n    return Artyom;\r\n}());\r\nexports.default = Artyom;\r\n\n\n//# sourceURL=webpack:///./node_modules/artyom.js/build/artyom.js?");

/***/ })

/******/ });